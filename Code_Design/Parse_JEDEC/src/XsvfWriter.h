/*
 * XsvfWriter.h
 *
 *  Created on: 30 Dec 2019
 *      Author: podonoghue
 */

#ifndef XSVFWRITER_H_
#define XSVFWRITER_H_

#include <cstdint>
#include "JedecFile.h"
#include "DeviceInformation.h"
#include "Xsvf.h"

class XsvfWriter {

   class GrayCounter {
      unsigned binaryCount = 0;

   public:
      /**
       * Increment count
       */
      void increment() {
         binaryCount++;
      }
      /**
       * Get current count value
       */
      unsigned getValue() {
         return binaryCount ^ (binaryCount >> 1);
      }

      /**
       * Get current count value in a bit-reversed format
       *
       * @param width   Width of number (number of bits) for reversal
       */
      unsigned getReversedValue(unsigned width) {
         unsigned normal = getValue();
         unsigned reverse = 0;
         for (unsigned bit=0; bit<width; bit++) {
            reverse = (reverse << 1) | (normal&0b1);
            normal >>= 1;
         }
         return reverse;
      }
   };

/*
const byte ProgAlgXC2C::ISC_ENABLE_OTF= 0xe4;
const byte ProgAlgXC2C::ISC_ENABLE    = 0xe8;
const byte ProgAlgXC2C::ISC_SRAM_READ = 0xe7;
const byte ProgAlgXC2C::ISC_WRITE     = 0xe6;
const byte ProgAlgXC2C::ISC_ERASE     = 0xed;
const byte ProgAlgXC2C::ISC_PROGRAM   = 0xea;
const byte ProgAlgXC2C::ISC_READ      = 0xee;
const byte ProgAlgXC2C::ISC_INIT      = 0xf0;
const byte ProgAlgXC2C::ISC_DISABLE   = 0xc0;
const byte ProgAlgXC2C::USERCODE      = 0xfd;
const byte ProgAlgXC2C::BYPASS        = 0xff;
*/
   static constexpr uint8_t Ex_Idle         = 0x00;
   static constexpr uint8_t Ex_DR_Pause     = 0x01;
   static constexpr uint8_t Ex_IR_Pause     = 0x01;

   static constexpr uint8_t IDCODE_COMMAND  = 0x01;
   static constexpr uint8_t BYPASS_COMMAND  = 0xFF;
   static constexpr uint8_t ENABLE_COMMAND  = 0xE8;
   static constexpr uint8_t ERASE_COMMAND   = 0xED;
   static constexpr uint8_t INIT_COMMAND    = 0xF0;
   static constexpr uint8_t CONLD_COMMAND   = 0xC0;
   static constexpr uint8_t VERIFY_COMMAND  = 0xEE;
   static constexpr uint8_t PROGRAM_COMMAND = 0xEA;

/// XSVF Command codes
enum XsvfCommand {
   /**
    * End of sequence
    */
   XCOMPLETE    = 0x00,
   /**
    * XTDOMASK value<"length" bits>
    *
    * Set TDO mask
    */
   XTDOMASK     = 0x01,
   /**
    * XSIR length<1 byte> TDIValue<"length" bits>
    *
    * Go to the Shift-IR state and shift in the TDIValue. If the last XRUNTEST time is non-zero, go to
    * the Run-Test/Idle state and wait for the last specified XRUNTEST time. Otherwise, go to the
    * last specified XENDIR state.
    */
   XSIR         = 0x02,
   /**
    * XSDR TDIValue<"length" bits>
    *
    * Go to the Shift-DR state and shift in TDIValue; compare the TDOExpected value from the last
    * XSDRTDO instruction against the TDO value that was shifted out (use the TDOMask that was
    * generated by the last XTDOMASK instruction). Length comes from the XSDRSIZE instruction.
    */
   XSDR         = 0x03,
   /**
    * XRUNTEST number<4 bytes>
    *
    * When the current XENDDR or XENDIR state is Run-Test/Idle (see XENDDR and XENDIR
    * commands), XRUNTEST defines the minimum number of TCK cycles to be applied in the
    * Run-Test/Idle state and the minimum number of microseconds the device should be in the
    * Run-Test/Idle state after each visit to the SDR (or SIR) state.
    * The single XRUNTEST number is a specification for both the minimum number of TCK cycles and
    * minimum number of microseconds to wait.
    * After transitioning from SDR (or SIR) to the Run-Test/Idle state, the
    * XSVF interpreter must apply the minimum number of TCK cycles and also must stay within the
    * Run-Test/Idle state for a minimum number of microseconds as specified by the last
    * XRUNTEST command.
    * If no prior XRUNTEST command exists, then the XSVF interpreter assumes an initial XRUNTEST number of zero.
    */
   XRUNTEST     = 0x04,
   /**
    * XREPEAT times<1 byte>
    * XREPEAT defines the number of times that TDO is tested against the expected value
    * before the ISP operation is considered a failure.
    *
    * NOT IMPLEMENTED - IGNORED
    */
   XREPEAT      = 0x07,
   /**
    * XSDRSIZE length<4 bytes>
    *
    * Specifies the length of all XSDR/XSDRTDO records that follow.
    */
   XSDRSIZE     = 0x08,
   /**
    * TDIValue<"length" bits> TDOExpected<"length" bits>
    *
    * Go to the Shift-DR state and shift in TDIValue; compare the TDOExpected value against the
    * TDO value that was shifted out (use the TDOMask which was generated by the last
    * XTDOMASK instruction). Length comes from the XSDRSIZE instruction.
    * If the TDO value does not match TDOExpected, perform the exception-handling sequence
    * described in the XC9500 programming algorithm section. If TDO is wrong more than the
    * maximum number of times specified by the XREPEAT instruction, then the ISP operation is
    * determined to have failed.
    * If the last XRUNTEST time is zero, then go to XENDDR state. Otherwise, go to the
    * Run_Test/Idle state and wait for the XRUNTEST time.
    * The TDOExpected Value is used in all successive XSDR instructions until the next XSDR
    * instruction is given.
    */
   XSDRTDO      = 0x09,
   /**
    * XSETSDRMASKS addressMask<"length" bits> dataMask<"length" bits>
    *
    * NOT IMPLEMENTED - ERROR
    */
   XSETSDRMASKS = 0x0A,
   /**
    * XSDRINC startAddress<"length" bits> numTimes<1 byte>
    *         data[1]<"length2" bits> ...data[numTimes]<"length2" bits>
    *
    * NOT IMPLEMENTED - ERROR
    */
   XSDRINC      = 0x0B,
   /**
    * XSDRB TDIValue<"length" bits>
    *
    * Go to the shift-DR state and shift in the TDI value. Continue to stay in the shift-DR state at the end
    * of the operation. No comparison of TDO value with the last specified TDOExpected is performed.
    */
   XSDRB        = 0x0C,
   /**
    * XSDRC TDIValue<"length" bits>
    *
    * Shift in the TDI value. Continue to stay in the shift-DR state at the end of the operation. No
    * comparison of TDO value with the last specified TDOExpected is performed.
    */
   XSDRC        = 0x0D,
   /**
    * XSDRE TDIValue<"length" bits>
    *
    * Shift in the TDI value. At the end of the operation, go to the XENDDR state. No comparison of
    * TDO value with the last specified TDOExpected is performed.
    */
   XSDRE        = 0x0E,
   /**
    * XSDRTDOB TDIValue<"length" bits> TDOExpected<"length" bits>
    *
    * Go to the shift-DR state and shift in TDI value; compare the TDOExpected value against the
    * TDO value that was shifted out. TDOMask is not applied. All bits of TDO are compared with the
    * TDOExpected. Length comes from the XSDRSIZE instruction.
    * Because this instruction is primarily meant for FPGAs, if the TDO value does not match
    * TDOExpected, the programming is stopped with an error message. At the end of the
    * operations, continue to stay in the SHIFT-DR state.
    */
   XSDRTDOB     = 0x0F,
   /**
    * XSDRTDOC TDIValue<"length" bits> TDOExpected<"length" bits>
    *
    * Shift in the TDI value; compare the TDOExpected value against the TDO value that was shifted
    * out. Length comes from the XSDRSIZE instruction. TDOMask is not applied. All bits of TDO are
    * compared with the TDOExpected.
    * If the TDO value does not match TDOExpected, stop the programming operation with an error
    * message. At the end of the operation, continue to stay in the SHIFT-DR state.
    */
   XSDRTDOC     = 0x10,
   /**
    * XSDRTDOE TDIValue<"length" bits> TDOExpected<"length" bits>
    *
    * Shift in the TDI value; compare the TDOExpected value against the TDO value that was shifted
    * out. Length comes from the last XSDSIZE instruction. TDOMask is not applied. All bits of TDO
    * are compared with the TDOExpected.
    * If the TDO value does not match the TDOExpected, stop the programming operations with an
    * error message. At the end of the operation, go to the XENDDR state.
    */
   XSDRTDOE     = 0x11,
   /**
    * XSTATE state<1 byte>
    *
    * If the state is Test-Logic-Reset, then force the TAP to the Test-Logic-Reset state via the
    * guaranteed TAP reset sequence: hold TMS High and apply a minimum of five TCK cycles. For
    * non-zero state values, if the TAP is already in the specified state, then do nothing. Otherwise,
    * transition the TAP to the next specified state.
    */
   XSTATE       = 0x12,
   /**
    * XENDIR state<1 byte>
    *
    * Set the XSIR end state to Run-Test/Idle or Pause-IR.
    * The default is Run-Test/Idle.
    */
   XENDIR       = 0x13,
   /**
    * XENDDR state<1 byte>
    *
    * Set the XSDR and XSDRTDO end state to Run-Test/Idle or Pause-DR.
    * The default is Run-Test/Idle.
    */
   XENDDR       = 0x14,
   /**
    * XSIR2 length<2 bytes> TDIValue<"length" bits>
    *
    * Go to the Shift-IR state and shift in the TDIValue. If the last XRUNTEST time is non-zero, go to
    * the Run-Test/Idle state and wait for the last specified XRUNTEST time. Otherwise, go to the
    * last specified XENDIR state.
    */
   XSIR2        = 0x15,
   /**
    * XCOMMENT char-string-ending-in-zero
    *
    * The XCOMMENT command specifies an arbitrary length character string that ends with a zero byte.
    */
   XCOMMENT     = 0x16,
   /**
    * XWAIT wait_state<1 byte> end_state<1 byte> wait_time<4 bytes>
    *
    * Go to the TAP wait_state, stay in the TAP wait_state for a minimum of wait_time (microseconds),
    * and finally go to the TAP end_state to complete the command.
    */
   XWAIT        = 0x17,

   /**
    * XSDR_TDO_CAPTURE <size-in-bits> <tdi-value>
    *
    * Capture TDO value
    */
   XSDR_TDOCAP = 0xF0,
};


private:
   Xsvf xsvf;

   void writeFill(unsigned postSize, unsigned padding, unsigned blockSize);

public:
   XsvfWriter() {
   }

   virtual ~XsvfWriter() {
   }

   void clear();

   void doPreamble();
   void doPostamble();
   void doErase();

   void confirmIdcode(const DeviceInformation &deviceInformation);
   void writeCppFile();

   void program(JedecFile &jedecFile, const DeviceInformation &deviceInformation);
   void verify(JedecFile &jedecFile, const DeviceInformation &deviceInformation);

   const Xsvf& getXsvf() const {
      return xsvf;
   }
};

#endif /* XSVFWRITER_H_ */
