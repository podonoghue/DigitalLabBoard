/**
 * @file     smc.h (180.ARM_Peripherals/Project_Headers/smc.h)
 * @brief    System Management Controller
 *
 * @version  V4.12.1.210
 * @date     13 April 2016
 */

#ifndef HEADER_SMC_H
#define HEADER_SMC_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "string.h"
#include "pin_mapping.h"
#include "mcg.h"

namespace USBDM {

/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */

/**
 *  Sleep on exit from Interrupt Service Routine (ISR)\n
 *  This option controls whether the processor re-enters sleep mode when exiting the\n
 *  handler for the interrupt that awakened it.
 */
enum SmcSleepOnExit {
   SmcSleepOnExit_Disabled = 0,                       //!< Processor does not re-enter SLEEP/DEEPSLEEP mode on completion of interrupt.
   SmcSleepOnExit_Enabled  = SCB_SCR_SLEEPONEXIT_Msk, //!< Processor re-enters SLEEP/DEEPSLEEP mode on completion of interrupt.
};

/**
 * @brief Template class representing the System Mode Controller (SMC)
 *
 * Partially based on Freescale Application note AN4503\n
 * Support for Kinetis Low Power operation.
 *
 * @image html KinetisPowerModes.png
 */
template <class Info>
class SmcBase_T : public Info {

protected:
	   /** Hardware instance pointer */
	   static constexpr HardwarePtr<SMC_Type> smc = Info::baseAddress;

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the currently configured STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.\n
    * The stop mode to enter may be set by setStopMode().
    * Other options that affect stop mode may be set by setStopOptions().
    *
    * @note This function is loaded in RAM as stop may power down flash
    */
__attribute__((section(".ram_functions")))
__attribute__((long_call))
__attribute__((noinline))
   static void _enterStopMode() {
      // Set deep sleep
      SCB->SCR = SCB->SCR | SCB_SCR_SLEEPDEEP_Msk;
      (void)SCB->SCR;
      __DSB();
      __WFI();
      __ISB();
   }

public:

   /**
    * Get name from SMC status e.g. RUN, VLPR, HSRUN
    *
    * @param status
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName(SmcStatus status) {
#ifdef SMC_PMPROT_AHSRUN
      if (status == SmcStatus_HSRUN) {
         return "HSRUN";
      }
#endif
      if (status == SmcStatus_RUN) {
         return "RUN";
      }
      if (status == SmcStatus_VLPR) {
         return "VLPR";
      }
      return "Impossible while running!";
   }

   /**
    * Get name for current SMC status  e.g. RUN, VLPR, HSRUN
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName() {
      return getSmcStatusName(Info::getStatus());
   }

   /**
    * Basic enable of SMC\n
    * Includes configuring all pins
    */
   static __attribute__((always_inline)) void enable() {
      // No clock or pins
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param[in] smcStopMode Stop mode to set.  This will become the default STOP mode.
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(SmcStopMode smcStopMode) {
      Info::setStopMode(smcStopMode);

      return enterStopMode();
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with the current STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode() {
      /*
       * Actions required before entry to STOP modes
       */
      // Save current Flash Bank0 settings
      FmcInfo::FlashBank0Init savedFlashBank0Settings;
      savedFlashBank0Settings.readConfig();
      // Disable Flash Bank0 prefetch
      FmcInfo::setFlashBank0Speculation(FmcFlashSpeculation_Disabled);

      _enterStopMode();
      /*
       * Actions required after exit from STOP modes
       */
      // Restore flash Bank0 settings
      savedFlashBank0Settings.configure();

      return (smc->PMCTRL & SMC_PMCTRL_STOPA_MASK)?E_INTERRUPTED:E_NO_ERROR;
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with given STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param smcInit    Settings to apply before entering STOP mode
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(typename Info::Init smcInit) {
      smcInit.setOptions();
      return enterStopMode();
   }

   /**
    * Enter Wait Mode (WAIT, VLPW)\n
    * (ARM core SLEEP mode)
    *
    * The processor will stop execution and enter WAIT/VLPW mode.\n
    * This function can be used to enter normal WAIT mode or VLPW mode
    * depending upon current run mode.\n
    * In wait mode the core clock is disabled (no code executing),
    * but bus clocks are enabled (peripheral modules are operational).
    *
    * Possible power mode transitions:
    * - RUN  -> WAIT
    * - VLPR -> VLPW
    *
    * WAIT mode is exited using any enabled interrupt or RESET.
    *
    * For Kinetis K:
    * If in VLPW mode, the statue of the SMC_PMCTRL[LPWUI] bit
    * determines if the processor exits to VLPR or RUN mode.\n
    * Use setExitVeryLowPowerOnInterrupt() to modify this action.
    *
    * For Kinetis L:
    * LPWUI does not exist.\n
    * Exits with an interrupt from VLPW will always be back to VLPR.\n
    * Exits from an interrupt from WAIT will always be back to RUN.
    *
    * @note Some modules include a programmable option to disable them in wait mode.\n
    * If those modules are programmed to disable in wait mode, they will not be able to
    * generate interrupts to wake the core.
    */
   static void enterWaitMode() {
      SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPDEEP_Msk;
      // Make sure write completes
      (void)(SCB->SCR);
      __asm volatile( "dsb" ::: "memory" );
      __asm volatile( "wfi" );
      __asm volatile( "isb" );
   }

   /**
    * Set Sleep-on-exit action
    *
    * If enabled, when the processor completes the execution of all exception handlers it
    * returns to Thread mode and immediately enters WAIT/STOP mode (ARM core SLEEP/DEEPSLEEP mode).\n
    * Use this mechanism in applications that only require the processor to run when
    * an exception occurs.
    *
    * @param[in] smcSleepOnExit Determines action on completion of all exception handlers
    */
   static void setSleepOnExit(SmcSleepOnExit smcSleepOnExit=SmcSleepOnExit_Enabled) {
      if (smcSleepOnExit) {
         SCB->SCR = SCB->SCR | SCB_SCR_SLEEPONEXIT_Msk;
      }
      else {
         SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPONEXIT_Msk;
      }
      // Make sure write completes
      (void)(SCB->SCR);
   }
   
   /**
    * Enter Run Mode.
    *
    * This may be used to change between supported RUN modes (RUN, VLPR, HSRUN).

    * Only the following transitions are allowed: VLPR <-> RUN <-> HSRUN.
    *
    * @param[in] clockConfig Clock configuration (Includes run mode to enter)
    *
    * @return E_NO_ERROR                 No error
    * @return E_CLOCK_INIT_FAILED        Clock transition failure
    * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to smcRunMode from current run mode
    */
   static ErrorCode enterRunMode(ClockConfig clockConfig) {
   
      SmcRunMode smcRunMode = Mcg::clockInfo[clockConfig].runMode;
   
      ErrorCode rc = E_NO_ERROR;
   
      /*
       * Transition    Change clock configuration
       * VLPR->RUN     After
       * RUN->VLPR     Before
       */
      switch(smcRunMode) {
   
         case SmcRunMode_Normal:
            // Change power mode
            SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
   
            // Wait for power status to change
            while (Info::getStatus() != SmcStatus_RUN) {
               __asm__("nop");
            }
            // Change clock mode
            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
            break;
   
         case SmcRunMode_VeryLowPower:
            // Change clock mode
            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
            if (rc != E_NO_ERROR) {
               break;
            }
            // Change power mode
            SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
   
            // Wait for power status to change
            while (Info::getStatus() != SmcStatus_VLPR) {
               __asm__("nop");
            }
            break;
         default:
            return setErrorCode(E_ILLEGAL_PARAM);
      }
      return rc;
   }

   
   /**
    * Change power mode.
    *
    * @note Note this method does not affect advanced STOP options such as PORPO and RAM2PO
    *       These should be set beforehand.
    *
    * @param smcPowerMode  Power mode to change to (apart from SmcPowerMode_RUN/VLPR/HSRUN)
    *
    * @return E_NOERROR                   Success
    * @return E_ILLEGAL_PARAM             Cannot enter RUN or VLPR using this method (use enterRunMode())
    * @return E_ILLEGAL_POWER_TRANSITION  It is not possible to transition directly to the given power mode
    * @return E_INTERRUPTED               Processor failed to change mode due to interrupt
    */
   static ErrorCode enterPowerMode(SmcPowerMode smcPowerMode) {
   
      switch(smcPowerMode) {
   
         // Transition refers to Figure 15-5. Power mode state diagram in MK22F Manual (K22P121M120SF7RM)
   
         case SmcPowerMode_RUN   : // (VLPR,HSRUN)->RUN Transition 3,12
         case SmcPowerMode_VLPR  : // RUN->VLPR         Transition 3
            // Clock changes needed etc. Use enterRunMode()
            return E_ILLEGAL_PARAM;
   
         case SmcPowerMode_VLPW  : // VLPR->VLPW        Transition 4
            // Check if in correct run mode
            if (SmcRunMode_VeryLowPower != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
               return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
            }
            [[fallthrough]];
         case SmcPowerMode_WAIT  : // (RUN,VLPR)->VLPW  Transition 1,4
            enterWaitMode();
            return E_NO_ERROR;
            break;
   
         case SmcPowerMode_NormalSTOP   : // RUN->STOP Transition 2a
            // Check if in correct run mode
            if (SmcRunMode_Normal != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
               return E_ILLEGAL_POWER_TRANSITION;
            }
            [[fallthrough]];
         case SmcPowerMode_VLPS  :        // (RUN,VLPR)->VLPS  Transition 7,6 
         case SmcPowerMode_VLLS0 :        // (RUN,VLPR)->VLLS0 Transition 8a,9a
         case SmcPowerMode_VLLS1 :        // (RUN,VLPR)->VLLS1 Transition 8b,9b
         case SmcPowerMode_VLLS2 :        // (RUN,VLPR)->VLLS2/LLS2 Transition 8c,9c
         case SmcPowerMode_VLLS3 :        // (RUN,VLPR)->VLLS3/LLS3 Transition 8d,9d 
            // Set partial_stop and (v)lls options
            smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_VLLSM_MASK)|(smcPowerMode>>8);
   
            return enterStopMode((SmcStopMode)(smcPowerMode&SMC_PMCTRL_STOPM_MASK));
      }
      return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
   }

   
   /**
    * Default value for Smc::Init
    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->SMC)
    */
   static constexpr SmcInfo::Init DefaultInitValue {
      SmcAllowVeryLowPower_Enabled , // Allow very low power modes - VLPR, VLPW and VLPS are allowed
      SmcAllowLowLeakageStop_Enabled , // Allow low leakage stop mode - LLS is allowed
      SmcAllowVeryLowLeakageStop_Enabled , // Allow very low leakage stop mode - VLLSx is allowed
      SmcExitLowPowerOnInt_Disabled , // Exit low power on interrupt - Stay in VLPR on int
      SmcStopMode_NormalStop , // Stop Mode Control - Normal Stop (STOP)
      SmcPowerOnResetInVlls0_Enabled , // Power-On_Reset Detection in VLLS0 mode - POR detect circuit is enabled in VLLS0
      SmcLowLeakageStopMode_VLLS3,  // Low Leakage Mode Control - Enter VLLS3 in VLLSx mode
   };
   
   /**
    * Configure with settings from <b>Configure.usbdmProject</b>.
    */
   static void defaultConfigure() {
      DefaultInitValue.initialise();
   }


};

   /**
    * Class representing SMC
    */
   class Smc : public SmcBase_T<SmcInfo> {};

/**
 * End SMC_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_SMC_H */
