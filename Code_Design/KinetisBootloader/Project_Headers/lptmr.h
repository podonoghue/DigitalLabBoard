/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */

#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), ///< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), ///< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), ///< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif

/**
 * @brief Template class representing a Low Power Timer
 */
template<class Info>
class LptmrBase_T : public Info {

protected:
   /** Minimum resolution required when setting interval */
   static constexpr int MINIMUM_RESOLUTION = 100;

   /** Callback function for ISR */
   static typename Info::CallbackFunction sCallback;

   /** Hardware instance */
   static constexpr HardwarePtr<LPTMR_Type> lptmr = Info::baseAddress;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
// Template _mapPinsOption.xml (/LPTMR0/classInfo)

   /**
    * Configures all mapped pins associated with ---Symbol not found or format incorrect for substitution  => key=/LPTMR0/_base_name, def=null, mod=null
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable && !(MapAllPinsOnStartup || ForceLockedPins)) {
         Info::initPCRs();
      }
   }

   /**
    * Disabled all mapped pins associated with ---Symbol not found or format incorrect for substitution  => key=/LPTMR0/_base_name, def=null, mod=null
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable && !(MapAllPinsOnStartup || ForceLockedPins)) {
         Info::clearPCRs();
      }
   }

   /**
    * Basic enable of ---Symbol not found or format incorrect for substitution  => key=/LPTMR0/_base_name, def=null, mod=null
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      Info::enableClock();
      configureAllPins();
   }

   /**
    * Disables the clock to ---Symbol not found or format incorrect for substitution  => key=/LPTMR0/_base_name, def=null, mod=null and all mapped pins
    */
   static void disable() {
      disableNvicInterrupts();
      
      disableAllPins();
      Info::disableClock();
   }
// End Template _mapPinsOption.xml

   /**
    * Configure LPTMR in time counting mode.
    * The timer is enabled
    *
    * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
    * @param lptmrInterrupt      Enables LPTMR interrupts
    * @param lptmrClockSel       Clock source for LPTMR
    * @param ticks               Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments. 
    *        The hardware trigger will assert until the next time the counter increments. 
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    * @param lptmrPrescale       Configures the size of the Prescaler in Time Interval mode
    */
   static void configureTimeIntervalMode(
         LptmrResetOnCompare lptmrResetOnCompare,
         LptmrInterrupt      lptmrInterrupt,
         LptmrClockSel       lptmrClockSel,
         Ticks               ticks               = 65535_ticks,
         LptmrPrescale       lptmrPrescale       = LptmrPrescale_Direct) {
   
      enable();
      // Change settings with timer disabled
      lptmr->CSR = lptmrResetOnCompare|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;
   
      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrPrescale;
   
      // Set event time
      lptmr->CMR = ticks;
   
      // Enable timer
      lptmr->CSR = lptmrResetOnCompare|lptmrInterrupt|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   }

   /**
    * Configure LPTMR in time counting mode.
    * The timer is enabled
    *
    * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
    * @param lptmrInterrupt      Enables LPTMR interrupts
    * @param seconds             Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments. 
    *        The hardware trigger will assert until the next time the counter increments. 
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    * @param lptmrClockSel       Clock source for LPTMR
    */
   static ErrorCode configureTimeIntervalMode(
         LptmrResetOnCompare lptmrResetOnCompare,
         LptmrInterrupt      lptmrInterrupt,
         Seconds             seconds,
         LptmrClockSel       lptmrClockSel       = LptmrClockSel_Lpoclk) {
   
      enable();
   
      uint8_t  psr = lptmrClockSel;
      uint32_t cmr;
   
      ErrorCode rc = calculateDurationValues(seconds, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
   
      // Change settings with timer disabled
      lptmr->CSR = lptmrResetOnCompare|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;
   
      // Set clock source and prescaler
      lptmr->PSR = psr;
   
      // Set event time
      lptmr->CMR = cmr;
   
      // Enable timer
      lptmr->CSR = lptmrResetOnCompare|lptmrInterrupt|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   
      return E_NO_ERROR;
   }

   /**
    * Configure LPTMR in pulse counting mode.
    * Provides selection of input pin, edge selection and reset mode.
    * The timer is enabled and pins configured.
    *
    * @param lptmrPinSel         Input source to be used in Pulse Counter mode
    * @param lptmrPulseEdge      Polarity of the input source in Pulse Counter mode
    * @param lptmrClockSel       Clock source for LPTMR
    * @param lptmrGlitchFilter   Configures the size of the glitch filter in Pulse Counting mode
    * @param lptmrResetOnCompare Counter action when lptmr_csr_tcf is set
    * @param lptmrInterrupt      Enables LPTMR interrupts
    * @param ticks               Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments. 
    *        The hardware trigger will assert until the next time the counter increments. 
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    */
   static void configurePulseCountingMode(
         LptmrPinSel         lptmrPinSel,
         LptmrPulseEdge      lptmrPulseEdge,
         LptmrClockSel       lptmrClockSel       = LptmrClockSel_Lpoclk,
         LptmrGlitchFilter   lptmrGlitchFilter   = LptmrGlitchFilter_Direct,
         LptmrResetOnCompare lptmrResetOnCompare = LptmrResetOnCompare_Enabled,
         LptmrInterrupt      lptmrInterrupt      = LptmrInterrupt_Disabled,
         Ticks               ticks               = 65535_ticks) {
   
      enable();
   
      // Change settings with timer disabled
      lptmr->CSR = lptmrPinSel|lptmrPulseEdge|lptmrResetOnCompare|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK;
   
      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrGlitchFilter;
   
      // Set Event time
      lptmr->CMR = ticks;
   
      // Enable timer
      lptmr->CSR = lptmrPinSel|lptmrPulseEdge|lptmrResetOnCompare|lptmrInterrupt|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   }


// /LPTMR/InitMethod not found
   /**
    * Configure LPTMR from values specified in init.
    *
    * @param init Class containing initialisation information
    */
   static ErrorCode configure(const typename Info::Init &init) {

      // Enable peripheral clock and map pins
      enable();

      if constexpr (Info::irqHandlerInstalled) {
         // Only set call-back if feature enabled and non-null
         if (init.callbackFunction != nullptr) {
            setCallback(init.callbackFunction);
         }
         enableNvicInterrupts(init.irqlevel);
      }
      uint8_t  psr = init.psr;
      uint32_t cmr = init.cmr;

      if (init.cmrperiod != 0) {
         // Calculate values from duration in seconds
         ErrorCode rc = calculateDurationValues(init.cmrperiod, psr, cmr);
         if (rc != E_NO_ERROR) {
            return rc;
         }
      }
      // Change settings with timer disabled
      lptmr->CSR = 0;

      // Update clock setting
      lptmr->PSR = psr;

      // Timer Compare Register
      lptmr->CMR = cmr;

      // Enable timer
      lptmr->CSR = init.csr|LPTMR_CSR_TEN_MASK;

      return E_NO_ERROR;
   }

   /**
    * Restarts the counter\n
    * Mostly for debug.
    */
   static void restart() {
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      lptmr->CSR   = csr|LPTMR_CSR_TCF_MASK;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set callback for ISR and enable NVIC interrupts.
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(typename Info::CallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "LPTMR not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * PIT interrupt handler. \n
    * Calls PIT0 callback
    */
   static void irqHandler() {
      // Clear interrupt flag
      lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;

      sCallback();
   }

   /**
    * Converts a number in ticks to time in microseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static uint32_t convertTicksToMicroseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in milliseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in seconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in seconds (as float)
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Seconds convertTicksToSeconds(Ticks ticks) {
      float tickRate = Info::getClockFrequencyF();
      return ((float)ticks)/tickRate;
   }

   /**
    * Converts a time in microseconds to number of ticks.
    *
    * @param[in]  time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   /**
    * Converts a time in milliseconds to number of ticks.
    *
    * @param[in]  time Time in milliseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMillisecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in seconds to number of ticks
    *
    * @param[in]  time Time in seconds (float!)
    *
    * @return Time in ticks
    *
    * @note Uses floating point
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertSecondsToTicks(Seconds time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = (unsigned)((float)time*tickRate);

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Calculate timing information based on desired duration
    *
    * @param[in]     duration  Desired period or event duration
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    * @param[out]    cmr        Compare register value
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint32_t &cmr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         float    clockFrequency = inputClock/prescaleFactor;
         uint32_t mod   = rintf(duration*clockFrequency)-1;
         if (mod < Info::minimumResolution) {
            // Too short a period for reasonable resolution
            return setAndCheckErrorCode(E_TOO_SMALL);
         }
         if (mod <= LPTMR_CMR_COMPARE_MASK) {
            cmr  = mod;
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Calculate filter information based on desired interval
    * This calculates a clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]     interval   Desired filter interval
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateFilterValues(Seconds interval, uint8_t &psr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         if ((float)(interval*prescaleFactor) < inputClock) {
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a duration
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period of timer.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode setPeriod(Seconds period) {

      uint8_t  psr = lptmr->PSR;
      uint32_t cmr;
      ErrorCode rc = calculateDurationValues(period, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable before changing clock
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->CMR  = cmr;
      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Set glitch filter interval.
    * This adjusts the clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]  interval Interval in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setFilterInterval(Seconds interval) {

      uint8_t  psr = lptmr->PSR;

      ErrorCode rc = calculateFilterValues(interval, psr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Get timer counter value
    *
    * @return Timer value in ticks.
    */
   static Ticks getCounterValue() {
      // It is necessary to write to the CNR to capture current value
      lptmr->CNR = 0;
      return (Ticks)(lptmr->CNR);
   }

};

template<class Info> typename Info::CallbackFunction LptmrBase_T<Info>::sCallback = LptmrBase_T<Info>::unhandledCallback;

   /**
    * MACRO defining the start of a interrupt handler for a LPTMR
    * This will override the handler incorporated within the LPTMR class.
    *
    * @example
    * LPTMR0_HANDLER() {
    *    console.writeln("PIT Channel 0 Handler");
    *    // Clear interrupt flag
    *    lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;
    * }
    */
   #define LPTMR0_HANDLER() template<> void Lptmr0::irqHandler()

   /**
    * Class representing LPTMR0
    *
    * <b>Example</b>
    * @code
    *
    * // LPTMR callback
    * void flash(void) {
    *    RED_LED::toggle();
    * }
    *
    * ...
    *
    * // Configure LPTMR in time counting mode
    * Lptmr0::configureTimeIntervalMode(
    *      LptmrResetOn_Compare,
    *      LptmrInterrupt_Enabled,
    *      LptmrClockSel_Lpoclk);
    *
    * // Set period of timer event
    * Lptmr0::setPeriod(5_s);
    *
    * // Set call-back
    * Lptmr0::setCallback(flash);
    * @endcode
    */
   class Lptmr0 : public LptmrBase_T<Lptmr0Info> {
   public:
      /**
       * Default value for Lptmr::PulseCountingModeInit
       * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
       */
      static constexpr PulseCountingModeInit DefaultPulseCountingModeInitValue {
         LptmrPinSel_Cmp0,  // Input Pin - CMP0 output
         LptmrPulseEdge_Rising,  // Pin Polarity - Active-high source, rising-edge increments lptmr_cnr
         LptmrClockSel_Lpoclk,  // Clock Source - Low power oscillator (LPO - 1kHz)
         LptmrGlitchFilter_Direct,  // Filter Value - No glitch filter
         LptmrInterrupt_Disabled,  // Timer interrupt enable - Interrupt disabled
         LptmrResetOnCompare_Enabled,  // Counter Action on Compare Event - lptmr_cnr is reset whenever lptmr_csr_tcf is set
         65535_ticks,  // Timer Compare Register
      };

      /**
       * Default value for Lptmr::TimeIntervalModeInit
       * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
       */
      static constexpr TimeIntervalModeInit DefaultTimeIntervalModeInitValue {
         LptmrResetOnCompare_Enabled,  // Counter Action on Compare Event - lptmr_cnr is reset whenever lptmr_csr_tcf is set
         LptmrInterrupt_Disabled,  // Timer interrupt enable - Interrupt disabled
         LptmrClockSel_Lpoclk,  // Clock Source - Low power oscillator (LPO - 1kHz)
         LptmrPrescale_Direct,  // Prescaler Value - Prescaler = 1
         65535_ticks,  // Timer Compare Register
      };

      /**
       * Enable LPTMR with default configuration.
       *
       * Includes enabling clock and any pins used.
       * Sets LPTMR to default configuration
       */
      static void defaultConfigure() {
   
         if constexpr (0) {
            configure(DefaultPulseCountingModeInitValue);
         }
         else {
            configure(DefaultTimeIntervalModeInitValue);
         }
      }
   };


/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */
