/**
 * @file     pcr.h (180.ARM_Peripherals/Project_Headers/pcr.h)
 * @brief    Port Control Register interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_PCR_H
#define HEADER_PCR_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <math.h>
#include <algorithm>
#include <climits>
#include "derivative.h"
#include "error.h"

#if __cplusplus <= 201703L
#define consteval constexpr
#endif

// Variable Argument Macro (VA_MACRO) up to 10 arguments
#define USBDM_COUNT_ARGUMENTS_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, value, ...) value
#define USBDM_COUNT_ARGUMENTS(...) USBDM_COUNT_ARGUMENTS_( __VA_ARGS__ __VA_OPT__(,) 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define USBDM_CONCAT_(left, right) left ## right
#define USBDM_CONCAT(left, right)  USBDM_CONCAT_(left, right)

#define USBDM_VA_MACRO(MACRO, ...) USBDM_CONCAT(MACRO, USBDM_COUNT_ARGUMENTS(__VA_ARGS__))(__VA_ARGS__)

/*
 * Default port information
 */
namespace USBDM {

#if __GNUC__ > 10
// USBDM makes extensive use of enums as bit masks
#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion"
#endif

#pragma GCC push_options
#pragma GCC optimize ("Os")

/**
* Port pin index
*
* Global indices for port pins
*/
enum class PinIndex : int16_t {
   INVALID_PCR  = -2,   // Signal does not exist
   UNMAPPED_PCR = -3,   // Signal is not currently mapped to a pin
   FIXED_NO_PCR = -4,   // Signal has mapping to fixed pin
   MIN_PIN_INDEX = 0,   // First available pin (inclusive)
   Unassigned    = UNMAPPED_PCR,
   PTA0 = 0+0,
   PTA1 = 0+1,
   PTA2 = 0+2,
   PTA3 = 0+3,
   PTA4 = 0+4,
   PTA5 = 0+5,
   PTA6 = 0+6,
   PTA7 = 0+7,
   PTA8 = 0+8,
   PTA9 = 0+9,
   PTA10 = 0+10,
   PTA11 = 0+11,
   PTA12 = 0+12,
   PTA13 = 0+13,
   PTA14 = 0+14,
   PTA15 = 0+15,
   PTA16 = 0+16,
   PTA17 = 0+17,
   PTA18 = 0+18,
   PTA19 = 0+19,
   PTA20 = 0+20,
   PTA21 = 0+21,
   PTA22 = 0+22,
   PTA23 = 0+23,
   PTA24 = 0+24,
   PTA25 = 0+25,
   PTA26 = 0+26,
   PTA27 = 0+27,
   PTA28 = 0+28,
   PTA29 = 0+29,
   PTA30 = 0+30,
   PTA31 = 0+31,
   PTB0 = 32+0,
   PTB1 = 32+1,
   PTB2 = 32+2,
   PTB3 = 32+3,
   PTB4 = 32+4,
   PTB5 = 32+5,
   PTB6 = 32+6,
   PTB7 = 32+7,
   PTB8 = 32+8,
   PTB9 = 32+9,
   PTB10 = 32+10,
   PTB11 = 32+11,
   PTB12 = 32+12,
   PTB13 = 32+13,
   PTB14 = 32+14,
   PTB15 = 32+15,
   PTB16 = 32+16,
   PTB17 = 32+17,
   PTB18 = 32+18,
   PTB19 = 32+19,
   PTB20 = 32+20,
   PTB21 = 32+21,
   PTB22 = 32+22,
   PTB23 = 32+23,
   PTB24 = 32+24,
   PTB25 = 32+25,
   PTB26 = 32+26,
   PTB27 = 32+27,
   PTB28 = 32+28,
   PTB29 = 32+29,
   PTB30 = 32+30,
   PTB31 = 32+31,
   PTC0 = 64+0,
   PTC1 = 64+1,
   PTC2 = 64+2,
   PTC3 = 64+3,
   PTC4 = 64+4,
   PTC5 = 64+5,
   PTC6 = 64+6,
   PTC7 = 64+7,
   PTC8 = 64+8,
   PTC9 = 64+9,
   PTC10 = 64+10,
   PTC11 = 64+11,
   PTC12 = 64+12,
   PTC13 = 64+13,
   PTC14 = 64+14,
   PTC15 = 64+15,
   PTC16 = 64+16,
   PTC17 = 64+17,
   PTC18 = 64+18,
   PTC19 = 64+19,
   PTC20 = 64+20,
   PTC21 = 64+21,
   PTC22 = 64+22,
   PTC23 = 64+23,
   PTC24 = 64+24,
   PTC25 = 64+25,
   PTC26 = 64+26,
   PTC27 = 64+27,
   PTC28 = 64+28,
   PTC29 = 64+29,
   PTC30 = 64+30,
   PTC31 = 64+31,
   PTD0 = 96+0,
   PTD1 = 96+1,
   PTD2 = 96+2,
   PTD3 = 96+3,
   PTD4 = 96+4,
   PTD5 = 96+5,
   PTD6 = 96+6,
   PTD7 = 96+7,
   PTD8 = 96+8,
   PTD9 = 96+9,
   PTD10 = 96+10,
   PTD11 = 96+11,
   PTD12 = 96+12,
   PTD13 = 96+13,
   PTD14 = 96+14,
   PTD15 = 96+15,
   PTD16 = 96+16,
   PTD17 = 96+17,
   PTD18 = 96+18,
   PTD19 = 96+19,
   PTD20 = 96+20,
   PTD21 = 96+21,
   PTD22 = 96+22,
   PTD23 = 96+23,
   PTD24 = 96+24,
   PTD25 = 96+25,
   PTD26 = 96+26,
   PTD27 = 96+27,
   PTD28 = 96+28,
   PTD29 = 96+29,
   PTD30 = 96+30,
   PTD31 = 96+31,
   PTE0 = 128+0,
   PTE1 = 128+1,
   PTE2 = 128+2,
   PTE3 = 128+3,
   PTE4 = 128+4,
   PTE5 = 128+5,
   PTE6 = 128+6,
   PTE7 = 128+7,
   PTE8 = 128+8,
   PTE9 = 128+9,
   PTE10 = 128+10,
   PTE11 = 128+11,
   PTE12 = 128+12,
   PTE13 = 128+13,
   PTE14 = 128+14,
   PTE15 = 128+15,
   PTE16 = 128+16,
   PTE17 = 128+17,
   PTE18 = 128+18,
   PTE19 = 128+19,
   PTE20 = 128+20,
   PTE21 = 128+21,
   PTE22 = 128+22,
   PTE23 = 128+23,
   PTE24 = 128+24,
   PTE25 = 128+25,
   PTE26 = 128+26,
   PTE27 = 128+27,
   PTE28 = 128+28,
   PTE29 = 128+29,
   PTE30 = 128+30,
   PTE31 = 128+31,
   MAX_PIN_INDEX, // Last available pin (exclusive)
};
   
/**
* Port index
*
* Global indices for ports
*/
enum class PortIndex : int16_t {
   PortA = 0,
   PortB = 1,
   PortC = 2,
   PortD = 3,
   PortE = 4,
};
   
   /**
    * Map PinIndex to PortIndex e.g. PinIndex::PTA3 => PortIndex::PortA
    *
    * @param pinIndex
    *
    * @return portIndex
    */
   constexpr PortIndex mapPinToPort(PinIndex pinIndex) {
      return PortIndex(int(pinIndex)/32);
   }
   
   /**
    * Map PortIndex to base PinIndex e.g. PortIndex::PortA => PinIndex::PTA0
    *
    * @param portIndex
    *
    * @return pinIndex
    */
   constexpr PinIndex mapPortToPin(PortIndex portIndex) {
      return PinIndex(int(portIndex)*32);
   }
   

// Pin number for port pin within individual port e.g. GPIOB[31..0]
typedef uint8_t  PinNum;

#if (false)
class Ticks {

private:
   unsigned value = 0;

public:
   constexpr Ticks()                   = default;
   constexpr Ticks(const Ticks& other) = default;

   constexpr Ticks(int value)          : value(value) {}
   constexpr Ticks(unsigned value)     : value(value) {}
   constexpr Ticks(long value)         : value((unsigned)value) {}
   constexpr Ticks(unsigned long value): value((unsigned)value) {}
   constexpr Ticks(float    value)     : value(roundf(value)) {}
   constexpr Ticks(double    value)    : value(roundf(value)) {}
   Ticks(const volatile Ticks& other)  : value(other.value) {}

   Ticks &operator =(const Ticks &other) = default;

   auto &operator =(float other)                  {value = other;       return *this; }
   auto &operator =(const volatile Ticks &other)  {
      if (this != &other) {
         value = other.value;
      }
      return *this;
   }

   void  operator =(const Ticks &other) volatile  {
      if (this != &other) {
         value = other.value;
      }
   }

   constexpr auto getValue() const { return value; }
   unsigned getValue() const volatile { return value; }

   constexpr auto operator *(unsigned other) const { return Ticks(value*other); }
   constexpr auto operator *(float    other) const { return Ticks(value*other); }

   constexpr auto operator /(unsigned other) const { return Ticks(value/other); }
   constexpr auto operator /(float    other) const { return Ticks(value/other); }
   constexpr auto operator /(Ticks    other) const { return (value/other.getValue()); }

   constexpr auto operator +(const Ticks &other)    const { return Ticks(value+other.value); }
   constexpr auto operator +(const unsigned other)  const { return Ticks(value+other); }
   constexpr auto operator +(const int other)       const { return Ticks(value+(unsigned)other); }

   constexpr auto operator -(const Ticks &other)    const { return Ticks(value-other.value); }
   constexpr auto operator -(const unsigned other)  const { return Ticks(value-other); }
   constexpr auto operator -(const int other)       const { return Ticks(value-(unsigned)other); }

   constexpr auto operator ==(const Ticks &other)   const { return value==other.value; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }

   constexpr auto operator !=(const Ticks &other)   const { return value!=other.value; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }

   constexpr operator unsigned() const { return value; }
   explicit operator unsigned() const volatile { return value; }
};

class Seconds {

private:
   float value = 0.0;

public:
   constexpr Seconds()                       = default;
   constexpr Seconds(const Seconds& other)   = default;

//   constexpr Seconds(int value)              : value((float)value) {}
//   constexpr Seconds(unsigned value)         : value((float)value) {}
//   constexpr Seconds(long value)             : value((float)value) {}
//   constexpr Seconds(unsigned long value)    : value((float)value) {}
   constexpr Seconds(double value)           : value((float)value) {}
   Seconds(const volatile Seconds& other)    : value(other.getValue()) {}

   Seconds &operator =(const Seconds &other) = default;

   auto &operator =(float other)                    {value = other;       return *this; }
   auto &operator =(const volatile Seconds &other)  {value = other.value; return *this; }

   void  operator =(const Seconds &other) volatile {value = other.value; }

   constexpr auto getValue() const { return value; }
   float getValue() const volatile { return value; }

   constexpr auto operator *(float other)    const { return Seconds(value*other); }
   constexpr auto operator *(unsigned other) const { return Seconds(value*other); }
   constexpr auto operator *(int other)      const { return Seconds(value*other); }

   constexpr auto operator /(float other)    const { return Seconds(value/other); }
   constexpr auto operator /(unsigned other) const { return Seconds(value/other); }
   constexpr auto operator /(int other)      const { return Seconds(value/other); }

   constexpr auto operator /(Seconds other) const { return float(value/other.getValue()); }

   constexpr auto operator +(Seconds other)  const { return Seconds(value+other.value); }
   constexpr auto operator +(float other)    const { return Seconds(value+other); }
   constexpr auto operator +(unsigned other) const { return Seconds(value+other); }
   constexpr auto operator +(int other)      const { return Seconds(value+other); }

   constexpr auto operator -(Seconds other)  const { return Seconds(value-other.value); }
   constexpr auto operator -(float other)    const { return Seconds(value-other); }
   constexpr auto operator -(unsigned other) const { return Seconds(value-other); }
   constexpr auto operator -(int other)      const { return Seconds(value-other); }

   constexpr auto operator ==(const Seconds &other) const { return value==other.value; }
   constexpr auto operator ==(const float other)    const { return value==other; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }
   constexpr auto operator ==(int other)            const { return value==other; }

   constexpr auto operator !=(const Seconds &other) const { return value!=other.value; }
   constexpr auto operator !=(const float other)    const { return value!=other; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }
   constexpr auto operator !=(int other)            const { return value!=other; }

   constexpr auto operator <(const Seconds &other) const { return value<other.value; }
   constexpr auto operator <(const float other)    const { return value<other; }
   constexpr auto operator <(const unsigned other) const { return value<other; }
   constexpr auto operator <(int other)            const { return value<other; }

   constexpr auto operator <=(const Seconds &other) const { return value<=other.value; }
   constexpr auto operator <=(const float other)    const { return value<=other; }
   constexpr auto operator <=(const unsigned other) const { return value<=other; }
   constexpr auto operator <=(int other)            const { return value<=other; }

   constexpr auto operator >(const Seconds &other) const { return value>other.value; }
   constexpr auto operator >(const float other)    const { return value>other; }
   constexpr auto operator >(const unsigned other) const { return value>other; }
   constexpr auto operator >(int other)            const { return value>other; }

   constexpr auto operator >=(const Seconds &other) const { return value>=other.value; }
   constexpr auto operator >=(const float other)    const { return value>=other; }
   constexpr auto operator >=(const unsigned other) const { return value>=other; }
   constexpr auto operator >=(int other)            const { return value>=other; }

   constexpr operator float()    const { return value; }
   explicit  operator float()    const volatile { return value; }
   constexpr operator unsigned() const { return (unsigned)round(value); }
   constexpr operator uint32_t() const { return (uint32_t)round(value); }
   constexpr operator signed()   const { return (signed)round(value); }
   constexpr operator int32_t()  const { return (int32_t)round(value); }
};

class Hertz {
private:
   float value = 0.0;

public:
   constexpr Hertz()                      = default;
   constexpr Hertz(const Hertz& other)    = default;

//   constexpr Hertz(int value)             : value((float)value) {}
//   constexpr Hertz(unsigned value)        : value((float)value) {}
//   constexpr Hertz(long value)            : value((float)value) {}
//   constexpr Hertz(unsigned long value)   : value((float)value) {}
//   constexpr Hertz(float value)           : value((float)value) {}
   constexpr Hertz(double value)          : value((float)value) {}
   Hertz(const volatile Hertz& other)     : value(other.value) {}

   Hertz &operator =(const Hertz &other) = default;

   auto &operator =(float other)                 {value = other;       return *this; }
   auto &operator =(const volatile Hertz &other) {value = other.value; return *this; }

   void  operator =(const Hertz &other) volatile {value = other.value; }

   constexpr auto getValue() const { return value; }
   float getValue() const volatile { return value; }

   constexpr auto operator *(float other)    const { return Hertz(value*other); }
   constexpr auto operator *(unsigned other) const { return Hertz(value*other); }
   constexpr auto operator *(int other)      const { return Hertz(value*other); }

   constexpr auto operator /(float other)    const { return Hertz(value/other); }
   constexpr auto operator /(unsigned other) const { return Hertz(value/other); }
   constexpr auto operator /(int other)      const { return Hertz(value/other); }

   constexpr auto operator /(Hertz other) const { return (float)(value/other.getValue()); }

   constexpr auto operator +(Hertz other) const { return Hertz(value+other.value); }
   constexpr auto operator -(Hertz other) const { return Hertz(value+other.value); }

   constexpr auto operator ==(const Hertz &other)   const { return value==other.value; }
   constexpr auto operator ==(const float other)    const { return value==other; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }
   constexpr auto operator ==(int other)            const { return value==other; }

   constexpr auto operator !=(const Hertz &other)   const { return value!=other.value; }
   constexpr auto operator !=(const float other)    const { return value!=other; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }
   constexpr auto operator !=(int other)            const { return value!=other; }

   constexpr auto operator <(const Hertz &other)   const { return value<other.value; }
   constexpr auto operator <(const float other)    const { return value<other; }
   constexpr auto operator <(const unsigned other) const { return value<other; }
   constexpr auto operator <(int other)            const { return value<other; }

   constexpr auto operator <=(const Hertz &other)   const { return value<=other.value; }
   constexpr auto operator <=(const float other)    const { return value<=other; }
   constexpr auto operator <=(const unsigned other) const { return value<=other; }
   constexpr auto operator <=(int other)            const { return value<=other; }

   constexpr auto operator >(const Hertz &other)   const { return value>other.value; }
   constexpr auto operator >(const float other)    const { return value>other; }
   constexpr auto operator >(const unsigned other) const { return value>other; }
   constexpr auto operator >(int other)            const { return value>other; }

   constexpr auto operator >=(const Hertz &other)   const { return value>=other.value; }
   constexpr auto operator >=(const float other)    const { return value>=other; }
   constexpr auto operator >=(const unsigned other) const { return value>=other; }
   constexpr auto operator >=(int other)            const { return value>=other; }

   constexpr operator float()    const { return value; }
   constexpr operator unsigned() const { return (unsigned)round(value); }
   constexpr operator uint32_t() const { return (uint32_t)round(value); }
   constexpr operator signed()   const { return (signed)round(value); }
   constexpr operator int32_t()  const { return (int32_t)round(value); }
};

constexpr auto operator *(float left,     Seconds right)  { return Seconds(left*right.getValue()); }
constexpr auto operator *(unsigned left,  Seconds right)  { return Seconds(left*right.getValue()); }
constexpr auto operator *(int left,       Seconds right)  { return Seconds(left*right.getValue()); }

constexpr auto operator *(float left,     Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(unsigned left,  Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(int left,       Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(Ticks left,     Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(Seconds left,   Hertz right)    { return Ticks(left.getValue()*right.getValue()); }

constexpr auto operator /(float left,     Seconds right) { return Hertz(left/right.getValue()); }
constexpr auto operator /(unsigned left,  Seconds right) { return Hertz(left/right.getValue()); }
constexpr auto operator /(int left,       Seconds right) { return Hertz(left/right.getValue()); }

constexpr auto operator /(float left,     Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(unsigned left,  Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(int left,       Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(Ticks left,     Hertz right)   { return Seconds(left.getValue()/right.getValue()); }

#else
enum Ticks : unsigned {

};
//   using Ticks    = unsigned;
   using Seconds  = float;
   using Hertz    = float;
#endif

   /**
    * Create a value of type `To` from the bits of `from`.
    *
    * @tparam To       To type
    * @tparam From     From type
    * @param  from     Object to convert
    *
    * @return  object converted to target type
    */
   template<typename To, typename From>
   [[nodiscard]]
    constexpr To bit_cast(const From& from) noexcept {
      return __builtin_bit_cast(To, from);
   }

/**
 * Convenience class for sharing storage of time measurements in ticks and seconds
 */
union Seconds_Ticks {
   ///  Time in seconds or Ticks
   uint32_t value;

   constexpr Seconds_Ticks() : value(0) {}

   constexpr Seconds toSeconds() const { return bit_cast<float, unsigned>(value); }
   constexpr Ticks   toTicks()   const { return (Ticks)value; }

#if false
   constexpr void fromSeconds(Seconds seconds) { value = bit_cast<unsigned, float>(seconds.getValue()); }
   constexpr void fromTicks(Ticks ticks)       { value = ticks.getValue(); }
#else
   constexpr void fromSeconds(Seconds seconds) { value = bit_cast<unsigned, float>(seconds); }
   constexpr void fromTicks(Ticks ticks)       { value = ticks; }
#endif

};

   /*
    * Allows writing numbers with units e.g. 100_ms
    */
   consteval auto operator"" _ticks(unsigned long long int num) { return static_cast<Ticks>((unsigned)num); };
   consteval auto operator"" _ticks(long double num)            { return static_cast<Ticks>((float)num); };

   consteval auto operator"" _s(unsigned long long int num)     { return static_cast<Seconds>((double)num); };
   consteval auto operator"" _s(long double num)                { return static_cast<Seconds>((double)num); };

   consteval auto operator"" _ms(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.001)); };
   consteval auto operator"" _ms(long double num)               { return static_cast<Seconds>((double)(num*0.001)); };

   consteval auto operator"" _us(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.000001)); };
   consteval auto operator"" _us(long double num)               { return static_cast<Seconds>((double)(num*0.000001)); };

   consteval auto operator"" _ns(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.000000001)); };
   consteval auto operator"" _ns(long double num)               { return static_cast<Seconds>((double)(num*0.000000001)); };

   consteval auto operator"" _Hz(unsigned long long int num)    { return static_cast<Hertz>((double)num); };
   consteval auto operator"" _Hz(long double num)               { return static_cast<Hertz>((double)num); };

   consteval auto operator"" _kHz(unsigned long long int num)   { return static_cast<Hertz>((double)(num*1000)); };
   consteval auto operator"" _kHz(long double num)              { return static_cast<Hertz>((double)(num*1000)); };

   consteval auto operator"" _MHz(unsigned long long int num)   { return static_cast<Hertz>((double)(num*1000000)); };
   consteval auto operator"" _MHz(long double num)              { return static_cast<Hertz>((double)(num*1000000)); };

//   consteval auto operator"" _percent(unsigned long long int num)  { return static_cast<double>(num)*0.01; };
//   consteval auto operator"" _percent(long double num)             { return static_cast<double>(num)*0.01; };

   /**
    * IRQ priority levels
    * (nvic_irqLevel)
    *
    * Priority level used to configure the NVIC
    * Subset of available levels
    */
   enum NvicPriority : int8_t {
      NvicPriority_NotInstalled = (int8_t)255,                ///< Not Installed
      NvicPriority_VeryLow      = (1<<__NVIC_PRIO_BITS)-1,    ///< VeryLow
      NvicPriority_Low          = (NvicPriority_VeryLow*5/6), ///< Low
      NvicPriority_Midlow       = (NvicPriority_VeryLow*4/6), ///< Midlow
      NvicPriority_Normal       = (NvicPriority_VeryLow*3/6), ///< Normal
      NvicPriority_MidHigh      = (NvicPriority_VeryLow*2/6), ///< MidHigh
      NvicPriority_High         = (NvicPriority_VeryLow*1/6), ///< High
      NvicPriority_VeryHigh     = 0,                          ///< VeryHigh
   };


/**
 * Class to wrap a memory address as an array
 *
 * @tparam T         Type of array element
 * @tparam address   Memory address of start of array
 * @tparam size      Size of array (in elements)
 */
template<typename T, uint32_t address, size_t Size>
class MemoryAddressWrapper {

public:

   static constexpr size_t size = Size;

   /**
    * Array access
    *
    * @return Reference to element of type T
    *
    * @note The const below refers to the MemoryAddressWrapper being const not the implied array
    */
   constexpr T & __attribute__((always_inline)) operator[](size_t index) const {
      usbdm_assert(index<size, "Index out of range");
      return (reinterpret_cast<T *>(address))[index];
   }

};

/**
 * This is to allow use of hardware pointers in classes with a constexpr constructor !
 *
 * @tparam T  The type of the hardware to create a pointer for
 */
template<typename T>
class HardwarePtr {

private:
   HardwarePtr() = delete;
   HardwarePtr(const HardwarePtr&) = delete;
   HardwarePtr(HardwarePtr&&) = delete;

   // Address of hardware
   const uintptr_t ptr;

public:
   /**
    * Constructor for hardware pointer
    *
    * @param ptr  Address of hardware to be wrapped.
    */
   constexpr __attribute__((always_inline))  HardwarePtr(uintptr_t ptr) : ptr(ptr){};

   /**
    * Convert to pointer to the hardware
    *
    * @return Hardware pointer
    */
   constexpr auto __attribute__((always_inline))  operator->() const { return reinterpret_cast<volatile T *>(ptr);}

   /**
    * Convert to reference to the hardware
    *
    * @return Hardware pointer
    */
   constexpr auto & __attribute__((always_inline))  operator*() const { return *reinterpret_cast<volatile T *>(ptr);}

   /**
    * Convert to uint32_t
    *
    * @return uint32
    */
   constexpr __attribute__((always_inline))  operator uint32_t() const { return ptr; }

   /**
    * Get value as volatile pointer to hardware
    */
   constexpr __attribute__((always_inline))  operator volatile T *() const { return reinterpret_cast<volatile T *>(ptr);}
};

/**
 * Enable and set priority of interrupts in NVIC.
 *
 * @param[in]  irqNum        Interrupt number
 * @param[in]  nvicPriority  Interrupt priority
 *
 * @note Any pending interrupts are cleared before enabling.
 * @note NvicPriority_NotInstalled will actually disable interrupts
 */
void enableNvicInterrupt(IRQn_Type irqNum, NvicPriority nvicPriority);

/**
 * @addtogroup PeripheralPinTables Peripheral Information Classes
 * @brief Provides information about pins used by a peripheral
 * @{
 */

/**
 * Used to indicate or control the polarity of an I/O with selectable polarity
 */
enum Polarity : uint32_t {
   ActiveLow  = 0xFFFFFFFFU,  ///< Signal is active low i.e. Active => Low level, Inactive => High level
   ActiveHigh = 0x00000000U,  ///< Signal is active high i.e. Active => High level, Inactive => Low level
};


#ifdef PCC
/**
 * Enable clock to selected ports
 *
 * @param[in] pccAddress Address of PCC register for port to enable
 */
static inline void enablePortClocks(uint32_t pccAddress) {
   *(volatile uint32_t *)pccAddress = *(volatile uint32_t *)pccAddress | PCC_PCCn_CGC_MASK;
   __DMB();
};

/**
 * Disable clock to selected ports
 *
 * @param[in] pccAddress Address of PCC register for port to disable
 */
static inline void disablePortClocks(uint32_t pccAddress) {
   *(volatile uint32_t *)pccAddress = *(volatile uint32_t *)pccAddress & ~PCC_PCCn_CGC_MASK;
   __DMB();
};

#endif

#ifdef PORT_PCR_MUX_MASK

#ifndef PORT_PCR_LK
/**
 * Some devices don't have LK function on pin
 */
#define PORT_PCR_LK(x) (0)
#endif

#ifndef PORT_PCR_DSE
/**
 * Some devices don't have DSE function on pin
 */
#define PORT_PCR_DSE(x) (0)
#endif

#ifndef PORT_PCR_ODE
/**
 * Some devices don't have ODE function on pin
 * The open-drain mode is automatically selected when I2C function is selected for the pin
 */
#define PORT_PCR_ODE(x) 0
#endif

#ifndef PORT_PCR_PE
/**
 * Some devices don't have PE function on pin
 */
#define PORT_PCR_PE(x) 0
#endif

#ifndef PORT_PCR_PS
/**
 * Some devices don't have PS function on pin
 */
#define PORT_PCR_PS(x) 0
#endif

#ifndef PORT_PCR_SRE
/**
 * Some devices don't have PS function on pin
 */
#define PORT_PCR_SRE(x) 0
#endif

#ifndef PORT_PCR_PFE
/**
 * Some devices don't have PFE function on pin
 */
#define PORT_PCR_PFE(x) 0
#endif

/**
 * PCR value
 */
enum class PcrValue : uint32_t {
   // Using an ENUM prevents automatic conversions from uint32_t to PcrValue
};

constexpr uint32_t operator ~(PcrValue pcrValue) {
   return ~static_cast<uint32_t>(pcrValue);
}

constexpr uint32_t operator &(PcrValue pcrValue, uint32_t mask) {
   return static_cast<uint32_t>(pcrValue) & mask;
}

constexpr bool operator ==(PcrValue pcrValue, uint32_t mask) {
   return static_cast<uint32_t>(pcrValue) & mask;
}

   /**
    * Pin input filter
    * (port_pcr_pfe)
    *
    * Pin filtering on digital inputs
    */
   enum PinFilter : uint32_t {
      PinFilter_None    = PORT_PCR_PFE(0), ///< No pin filter
      PinFilter_Passive = PORT_PCR_PFE(1), ///< Pin filter enabled
   };

   /**
    * Pin pull device
    * (port_pcr_pd)
    *
    * Pin pull device (up/down/none) on digital inputs
    */
   enum PinPull : uint32_t {
      PinPull_None = PORT_PCR_PD(0b00), ///< No pull device
      PinPull_Up   = PORT_PCR_PD(0b11), ///< Weak pull-up
      PinPull_Down = PORT_PCR_PD(0b10), ///< Weak pull-down
   };

   /**
    * Pin drive strength
    * (port_pcr_dse)
    *
    * Pin drive strength of digital outputs
    */
   enum PinDriveStrength : uint32_t {
      PinDriveStrength_Low  = PORT_PCR_DSE(0), ///< Low drive strength
      PinDriveStrength_High = PORT_PCR_DSE(1), ///< High drive strength
   };

   /**
    * Pin drive mode
    * (port_pcr_ode)
    *
    * Pin drive mode (push-pull/open-drain) of digital outputs
    */
   enum PinDriveMode : uint32_t {
      PinDriveMode_PushPull  = PORT_PCR_ODE(0), ///< Push-pull
      PinDriveMode_OpenDrain = PORT_PCR_ODE(1), ///< Open-drain
   };

   /**
    * Pin slew rate
    * (port_pcr_sre)
    *
    * Pin slew rate of digital outputs
    */
   enum PinSlewRate : uint32_t {
      PinSlewRate_Fast = PORT_PCR_SRE(0), ///< Fast
      PinSlewRate_Slow = PORT_PCR_SRE(1), ///< Slow
   };

   /**
    * Pin Control Register (PCR) lock
    * (port_pcr_lk)
    *
    * Prevents modification of some of the PCR values once set
    */
   enum PinLock : uint32_t {
      PinLock_Unlocked = PORT_PCR_LK(0), ///< PCR not locked after 1st write
      PinLock_Locked   = PORT_PCR_LK(1), ///< PCR locked after 1st write
   };

   /**
    * Pin interrupt/DMA actions
    * (port_pcr_irqc)
    *
    * DMA and/or interrupt actions to happen on pin change or level
    */
   enum PinAction : uint32_t {
      PinAction_None       = PORT_PCR_IRQC(0),  ///< No interrupt or DMA function
      PinAction_DmaRising  = PORT_PCR_IRQC(1),  ///< Generate DMA request on rising edge
      PinAction_DmaFalling = PORT_PCR_IRQC(2),  ///< Generate DMA request on falling edge
      PinAction_DmaEither  = PORT_PCR_IRQC(3),  ///< Generate DMA request on either edge
      PinAction_IrqLow     = PORT_PCR_IRQC(8),  ///< Generate IRQ request on low level
      PinAction_IrqRising  = PORT_PCR_IRQC(9),  ///< Generate IRQ request on rising edge
      PinAction_IrqFalling = PORT_PCR_IRQC(10), ///< Generate IRQ request on falling edge
      PinAction_IrqEither  = PORT_PCR_IRQC(11), ///< Generate IRQ request on either edge
      PinAction_IrqHigh    = PORT_PCR_IRQC(12), ///< Generate IRQ request on high level
   };

   /**
    * Pin Multiplexor setting
    * (port_pcr_mux)
    *
    * Which function is mapped to the pin
    */
   enum PinMux : uint32_t {
      PinMux_Analogue = PORT_PCR_MUX(0), ///< Analogue function (ADC/TSI etc)
      PinMux_Gpio     = PORT_PCR_MUX(1), ///< GPIO function
      PinMux_2        = PORT_PCR_MUX(2), ///< Multiplexor 2 function
      PinMux_3        = PORT_PCR_MUX(3), ///< Multiplexor 3 function
      PinMux_4        = PORT_PCR_MUX(4), ///< Multiplexor 4 function
      PinMux_5        = PORT_PCR_MUX(5), ///< Multiplexor 5 function
      PinMux_6        = PORT_PCR_MUX(6), ///< Multiplexor 6 function
      PinMux_7        = PORT_PCR_MUX(7), ///< Multiplexor 7 function
      PinMux_Tsi      = PORT_PCR_MUX(0), ///< Touch Sense Input
      PinMux_Disabled = PORT_PCR_MUX(0), ///< Disabled
   };

   /**
    * Enable clock to selected ports
    *
    * @param[in] clockMask Mask for PORTs to enable
    */
   static inline void enablePortClocks(uint32_t clockMask) {
      SIM->SCGC5 = SIM->SCGC5 | clockMask;
      __DMB();
   }
   
   /**
    * Disable clock to selected ports
    *
    * @param[in] clockMask Mask for PORTs to disable
    */
   static inline void disablePortClocks(uint32_t clockMask) {
      SIM->SCGC5 = SIM->SCGC5 & ~clockMask;
      __DMB();
   }
   
   /**
    * Creates a bitmask with a single '1' in the bit location indicated
    *
    * @param bitNum
    *
    * @return Bit mask
    */
   static constexpr uint32_t makeBitMask(int bitNum) {
      if (bitNum < 0) {
         // Negative bitNum is used to indicate illegal value - suppress to reduce assert noise.
         return 0;
      }
      else {
         return (uint32_t)(1<<bitNum);
      }
   }

   constexpr inline PcrValue operator|(PcrValue op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PcrValue op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinPull op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinFilter op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveStrength op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinDriveMode op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinSlewRate op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinLock op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinAction op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinPull op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinFilter op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinDriveStrength op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinDriveMode op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinSlewRate op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinLock op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinAction op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }
   constexpr inline PcrValue operator|(PinMux op1, PinMux op2) { return static_cast<PcrValue>(static_cast<uint32_t>(op1)|static_cast<uint32_t>(op2)); }


   /** Port Clock enable masks **/
   static constexpr uint32_t PORTA_CLOCK_MASK = SIM_SCGC5_PORTA_MASK; ///< PORTA clock mask
   static constexpr uint32_t PORTB_CLOCK_MASK = SIM_SCGC5_PORTB_MASK; ///< PORTB clock mask
   static constexpr uint32_t PORTC_CLOCK_MASK = SIM_SCGC5_PORTC_MASK; ///< PORTC clock mask
   static constexpr uint32_t PORTD_CLOCK_MASK = SIM_SCGC5_PORTD_MASK; ///< PORTD clock mask
   static constexpr uint32_t PORTE_CLOCK_MASK = SIM_SCGC5_PORTE_MASK; ///< PORTE clock mask



template<typename ... V>
constexpr PcrValue pcrOr(const V &... v) {
  std::common_type_t<PcrValue> result = {};
  (void)std::initializer_list<uint32_t>{ (result = (result | v), 0U)... };
  return result;
}

/**
 * Force a PcrValue to refer to the GPIO function i.e. MUX field = PinMux_Gpio
 *
 * @param op   PCR value to base result on
 *
 * @return  Modified PCR value
 */
constexpr PcrValue gpioPcrValue(PcrValue op) {
   return (PcrValue)((op&~PORT_PCR_MUX_MASK)|PinMux_Gpio);
}

/**
 * Force a PcrValue to refer to the Analogue function i.e. MUX field = PinMux_Analogue
 *
 * @param op   PCR value to base result on
 *
 * @return  Modified PCR value
 */
constexpr PcrValue analoguePcrValue(PcrValue op) {
   return (PcrValue)((op&~PORT_PCR_MUX_MASK)|PinMux_Analogue);
}


   /**
    *
    * Class used to do initialisation of GPIO PCR value
    *
    * This class has a templated constructor that accepts a list of options to set.
    * Options not explicitly mentioned are cleared to 0.
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example1:
    * @code
    * // Initialisation value
    * static constexpr PcrInit pcrInit(PinDriveStrength_High, PinSlewRate_Slow, PinPull_Down, PinFilter_Passive);
    *
    * Initialise devices
    * Led::setOutput(pcrInit.value);
    * Switch::setInput(pcrInit.value);
    * Cmt::setOutput(pcrInit.value);
    * @endcode
    */
   class PcrInit {
   
   private:
      PcrInit(PcrInit&&) = delete;
   
   public:
      /// Value for PCR register
      PcrValue value = (PcrValue)0;
   
      /**
       * Constructor
       */
      constexpr PcrInit()  {
      }
   
      /**
       * Construct from PcrValue
       *
       * @param value
       */
      constexpr PcrInit(PcrValue value) : value(value) {}
   
      /**
       * Construct from PcrInit
       *
       * @param other
       */
      constexpr PcrInit(const USBDM::PcrInit &other) : value(other.value) {}
   
      /**
       * Constructor
       * This version is appropriate for a pin used as a digital output
       *
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinSlewRate      Pin slew rate of digital outputs
       */
      constexpr PcrInit(
         PinDriveStrength pinDriveStrength,
         PinDriveMode     pinDriveMode,
         PinSlewRate      pinSlewRate
      ) : value (pinDriveStrength|pinDriveMode|pinSlewRate) {
      }
   
      /**
       * Constructor
       * This version is appropriate for a pin used as a digital input
       *
    * @param pinPull   Pin pull device (up/down/none) on digital inputs
    * @param pinFilter Pin filtering on digital inputs
    * @param pinAction DMA and/or interrupt actions to happen on pin change or level
       */
      constexpr PcrInit(
         PinPull   pinPull,
         PinFilter pinFilter,
         PinAction pinAction
      ) : value (pinPull|pinFilter|pinAction) {
      }
   
      /**
       * Constructor
       * This version is appropriate for a pin used as a digital input/output
       *
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    * @param pinPull          Pin pull device (up/down/none) on digital inputs
    * @param pinFilter        Pin filtering on digital inputs
    * @param pinAction        DMA and/or interrupt actions to happen on pin change or level
       */
      constexpr PcrInit(
         PinDriveStrength pinDriveStrength,
         PinDriveMode     pinDriveMode,
         PinSlewRate      pinSlewRate,
         PinPull          pinPull,
         PinFilter        pinFilter,
         PinAction        pinAction
      ) : value (pinDriveStrength|pinDriveMode|pinSlewRate|pinPull|pinFilter|pinAction) {
      }
   
      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinPull Pin pull device
       */
      template <typename... Types>
      constexpr PcrInit(PinPull pinPull, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinPull;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinFilter Pin input filter
       */
      template <typename... Types>
      constexpr PcrInit(PinFilter pinFilter, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinFilter;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinDriveStrength Pin drive strength
       */
      template <typename... Types>
      constexpr PcrInit(PinDriveStrength pinDriveStrength, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinDriveStrength;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinDriveMode Pin drive mode
       */
      template <typename... Types>
      constexpr PcrInit(PinDriveMode pinDriveMode, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinDriveMode;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinSlewRate Pin slew rate
       */
      template <typename... Types>
      constexpr PcrInit(PinSlewRate pinSlewRate, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinSlewRate;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinLock Pin Control Register (PCR) lock
       */
      template <typename... Types>
      constexpr PcrInit(PinLock pinLock, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinLock;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinAction Pin interrupt/DMA actions
       */
      template <typename... Types>
      constexpr PcrInit(PinAction pinAction, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinAction;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pinMux Pin Multiplexor setting
       */
      template <typename... Types>
      constexpr PcrInit(PinMux pinMux, Types... rest) : PcrInit(rest...)  {
   
         value = value | pinMux;
      }

      constexpr operator       PcrValue() const { return value; }
      constexpr operator       PcrValue()       { return value; }
      constexpr PcrValue       pcrValue() const { return value; }
      constexpr PcrValue       pcrValue()       { return value; }

      constexpr operator         PinPull() const { return static_cast<PinPull>(value&PORT_PCR_PD_MASK); }
      constexpr operator         PinPull()       { return static_cast<PinPull>(value&PORT_PCR_PD_MASK); }
      constexpr PinPull       pinPull() const { return static_cast<PinPull>(value&PORT_PCR_PD_MASK); }
      constexpr PinPull       pinPull()       { return static_cast<PinPull>(value&PORT_PCR_PD_MASK); }

      constexpr operator         PinFilter() const { return static_cast<PinFilter>(value&PORT_PCR_PFE_MASK); }
      constexpr operator         PinFilter()       { return static_cast<PinFilter>(value&PORT_PCR_PFE_MASK); }
      constexpr PinFilter       pinFilter() const { return static_cast<PinFilter>(value&PORT_PCR_PFE_MASK); }
      constexpr PinFilter       pinFilter()       { return static_cast<PinFilter>(value&PORT_PCR_PFE_MASK); }

      constexpr operator         PinDriveStrength() const { return static_cast<PinDriveStrength>(value&PORT_PCR_DSE_MASK); }
      constexpr operator         PinDriveStrength()       { return static_cast<PinDriveStrength>(value&PORT_PCR_DSE_MASK); }
      constexpr PinDriveStrength       pinDriveStrength() const { return static_cast<PinDriveStrength>(value&PORT_PCR_DSE_MASK); }
      constexpr PinDriveStrength       pinDriveStrength()       { return static_cast<PinDriveStrength>(value&PORT_PCR_DSE_MASK); }

      constexpr operator         PinDriveMode() const { return static_cast<PinDriveMode>(value&PORT_PCR_ODE_MASK); }
      constexpr operator         PinDriveMode()       { return static_cast<PinDriveMode>(value&PORT_PCR_ODE_MASK); }
      constexpr PinDriveMode       pinDriveMode() const { return static_cast<PinDriveMode>(value&PORT_PCR_ODE_MASK); }
      constexpr PinDriveMode       pinDriveMode()       { return static_cast<PinDriveMode>(value&PORT_PCR_ODE_MASK); }

      constexpr operator         PinSlewRate() const { return static_cast<PinSlewRate>(value&PORT_PCR_SRE_MASK); }
      constexpr operator         PinSlewRate()       { return static_cast<PinSlewRate>(value&PORT_PCR_SRE_MASK); }
      constexpr PinSlewRate       pinSlewRate() const { return static_cast<PinSlewRate>(value&PORT_PCR_SRE_MASK); }
      constexpr PinSlewRate       pinSlewRate()       { return static_cast<PinSlewRate>(value&PORT_PCR_SRE_MASK); }

      constexpr operator         PinLock() const { return static_cast<PinLock>(value&PORT_PCR_LK_MASK); }
      constexpr operator         PinLock()       { return static_cast<PinLock>(value&PORT_PCR_LK_MASK); }
      constexpr PinLock       pinLock() const { return static_cast<PinLock>(value&PORT_PCR_LK_MASK); }
      constexpr PinLock       pinLock()       { return static_cast<PinLock>(value&PORT_PCR_LK_MASK); }

      constexpr operator         PinAction() const { return static_cast<PinAction>(value&PORT_PCR_IRQC_MASK); }
      constexpr operator         PinAction()       { return static_cast<PinAction>(value&PORT_PCR_IRQC_MASK); }
      constexpr PinAction       pinAction() const { return static_cast<PinAction>(value&PORT_PCR_IRQC_MASK); }
      constexpr PinAction       pinAction()       { return static_cast<PinAction>(value&PORT_PCR_IRQC_MASK); }

      constexpr operator         PinMux() const { return static_cast<PinMux>(value&PORT_PCR_MUX_MASK); }
      constexpr operator         PinMux()       { return static_cast<PinMux>(value&PORT_PCR_MUX_MASK); }
      constexpr PinMux       pinMux() const { return static_cast<PinMux>(value&PORT_PCR_MUX_MASK); }
      constexpr PinMux       pinMux()       { return static_cast<PinMux>(value&PORT_PCR_MUX_MASK); }

   };

   /**
    * Default PCR value for pins used as GPIO (including multiplexor value)
    * High drive strength + Pull-up + GPIO_MUX value
    */
   static constexpr PcrValue GPIO_DEFAULT_PCR(PinPull_None|PinFilter_None|PinDriveStrength_Low|PinDriveMode_PushPull|PinSlewRate_Fast|PinLock_Unlocked|PinAction_None|PinMux_Gpio);


#if 0
/**
 * Port information
 * Information required to configure the PCR for a particular function
 */
class PortInfo {

private:
   PortInfo() = delete;
   PortInfo(const PortInfo&) = delete;
   PortInfo(PortInfo&&) = delete;

public:
   const NvicPriority  irqLevel;     ///< Interrupt priority level or NvicPriority_NotInstalled if handler not installed

   constexpr PortInfo(const NvicPriority  nvicPriority) :
               irqLevel(nvicPriority) {
   }
};
#endif

/**
 * Pin information
 */
class PinInfo {

private:
   PinInfo() = delete;
   PinInfo(const PinInfo&) = delete;
   PinInfo(PinInfo&&) = delete;

public:
   const PinIndex      pinIndex;     ///< Pin index for pin e.g. PTC3
   const PcrValue      pcrValue;     ///< Default PCR value for pin - Includes PinMux value which determines pin use in most cases

   /**
    * Constructor from portInfo etc.
    *
    * @param pinIndex      Pin index to determine associated GPIO
    * @param pcrValue      Default PCR value for pin
    */
   constexpr PinInfo(
         PinIndex        pinIndex,
         PcrValue        pcrValue) : pinIndex(pinIndex), pcrValue(pcrValue) {
   }
};

#ifdef PORT_DFCR_CS_MASK
   /**
    * Controls the Digital Pin Filter clock source
    */
   enum PinDigitalFilterClock {
      PinDigitalFilterClock_BusClock = PORT_DFCR_CS(0),///< Pin Digital Filter Clock = BusClock
      PinDigitalFilterClock_LpoClock = PORT_DFCR_CS(1),///< Pin Digital Filter Clock = Low Power Oscillator
   };
#endif

/**
 * Type definition for PORT interrupt call back.
 * This callback is shared by all port pins
 *
 * @param[in] status 32-bit value from ISFR (each bit indicates a pin interrupt source)
 */
typedef void (*PinCallbackFunction)(uint32_t status);

/**
 * Provides common unhandledCallback for all PORTs
 */
class PcrBase {

public:
   /**
    * Limit index to permitted bit index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param bitNum   Index to limit
    *
    * @return Index limited to permitted range
    */
   static inline constexpr int limitIndex(int bitNum) {
      if (bitNum<0) {
         return 0;
      }
      if (bitNum>=(int)(sizeof(uint32_t)*CHAR_BIT)) {
         return int((sizeof(uint32_t)*CHAR_BIT)-1);
      }
      return bitNum;
   }

   /**
    * Class to static check signal exists and is mapped to a pin
    *
    * @tparam pinIndex Pin index to check
    */
   template<PinIndex pinIndex> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Function is not currently mapped to a pin
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);
      // Peripheral signal does not exit
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);
      // Peripheral signal mapped directly to pin - no PCR (not an error)
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);
      // Illegal value
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));

      static_assert(check1, "Peripheral signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert(check2, "Peripheral signal doesn't exist in this device/package - Check Configure.usbdm for available signals");
      static_assert(check4, "Illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

#define CreatePinChecker(periph)                                                                                                                        \
   template<PinIndex pinIndex> class CheckPinExistsAndIsMapped {                                                                                        \
      /* Tests are chained so only a single assertion can fail so as to reduce noise */                                                                 \
                                                                                                                                                        \
      /* Function is not currently mapped to a pin */                                                                                                   \
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);                                                                              \
      /* Peripheral signal does not exit */                                                                                                             \
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);                                                                    \
      /* Peripheral signal mapped directly to pin - no PCR (not an error) */                                                                            \
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);                                                        \
      /* Illegal value */                                                                                                                               \
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));      \
                                                                                                                                                        \
      static_assert(check1, periph " signal is not mapped to a pin - Modify Configure.usbdm");                                                          \
      static_assert(check2, periph " signal doesn't exist in this device/package - Check Configure.usbdm for available signals");                       \
      static_assert(check4, periph " illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");                       \
                                                                                                                                                        \
   public:                                                                                                                                              \
      /** Dummy function to allow convenient in-line checking */                                                                                        \
      static constexpr void check() {}                                                                                                                  \
   };

#define CreatePeripheralPinChecker(periph)                                                                                                              \
   template<class Inf, int signalNum> class CheckPinExistsAndIsMapped {                                                                                \
                                                                                                                                                        \
      /* Check index is valid for peripheral INFO table */                                                                                              \
      static_assert(signalNum<Inf::numSignals, periph " illegal signal index");                                                                        \
                                                                                                                                                        \
      static constexpr PinIndex pinIndex = Inf::info[signalNum].pinIndex;                                                                              \
                                                                                                                                                        \
      /* Tests are chained so only a single assertion can fail so as to reduce noise */                                                                 \
                                                                                                                                                        \
      /* Function is not currently mapped to a pin */                                                                                                   \
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);                                                                              \
      /* Peripheral signal does not exit */                                                                                                             \
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);                                                                    \
      /* Peripheral signal mapped directly to pin - no PCR (not an error) */                                                                            \
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);                                                        \
      /* Illegal value */                                                                                                                               \
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));      \
                                                                                                                                                        \
      static_assert(check1, periph " signal is not mapped to a pin - Modify Configure.usbdm");                                                          \
      static_assert(check2, periph " signal doesn't exist in this device/package - Check Configure.usbdm for available signals");                       \
      static_assert(check4, periph " illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");                       \
                                                                                                                                                        \
   public:                                                                                                                                              \
      /** Dummy function to allow convenient in-line checking */                                                                                        \
      static constexpr void check() {}                                                                                                                  \
   };

   /**
    * Class to static check signal mapping is valid for a peripheral
    * Conditions are chained so only a single assert is reported
    *
    * @tparam Info         Info table used for lookup
    * @tparam signalNum    Index into table
    */
   template<class Info, int signalNum> class CheckSignalMapping {

      static constexpr PinIndex pinIndex = Info::info[signalNum].pinIndex;

      /* Illegal index for table */
      static_assert(signalNum<Info::numSignals, "Illegal signal index for this peripheral");

   public:
      static void check() {
         CheckPinExistsAndIsMapped<pinIndex>::check();
      }
   };

private:
   /**
    * This class is not intended to be instantiated
    */
   PcrBase() = delete;
   PcrBase(const PcrBase&) = delete;
   PcrBase(PcrBase&&) = delete;

public:
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   
   /**
    * Get PORT from portIndex
    *
    * @param portIndex Port index e.g. PortIndex::PortA. Used to determine return value
    *
    * @return Pointer to relevant PORT
    */
   static constexpr uint32_t getPortAddress(PortIndex portIndex) {
   
      if (portIndex <= PortIndex::PortA) {
         return PORTA_BasePtr;
      }
      if (portIndex <= PortIndex::PortB) {
         return PORTB_BasePtr;
      }
      if (portIndex <= PortIndex::PortC) {
         return PORTC_BasePtr;
      }
      if (portIndex <= PortIndex::PortD) {
         return PORTD_BasePtr;
      }
      if (portIndex <= PortIndex::PortE) {
         return PORTE_BasePtr;
      }
      static_assert("Illegal Port");
      return 0;
   }
   
   /**
    * Get PORT clock enable mask from pinIndex
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine return value
    *
    * @return Clock enable mask e.g. SIM_SCGC5_PORTB
    */
   static constexpr uint32_t getClockMask(PinIndex pinIndex) {
      if (pinIndex < PinIndex::MIN_PIN_INDEX) {
         // INVALID_PCR, UNMAPPED_PCR, FIXED_NO_PCR
         return 0;
      }
      if (pinIndex <= PinIndex::PTA31) {
         return SIM_SCGC5_PORTA_MASK;
      }
      if (pinIndex <= PinIndex::PTB31) {
         return SIM_SCGC5_PORTB_MASK;
      }
      if (pinIndex <= PinIndex::PTC31) {
         return SIM_SCGC5_PORTC_MASK;
      }
      if (pinIndex <= PinIndex::PTD31) {
         return SIM_SCGC5_PORTD_MASK;
      }
      if (pinIndex <= PinIndex::PTE31) {
         return SIM_SCGC5_PORTE_MASK;
      }
       static_assert("Illegal Port");
       return 0;
   }
   
   /**
    * Get PORT IRQ number from portIndex
    *
    * @param portIndex Port index e.g. PortB. Used to determine return value
    *
    * @return IRQ number
    */
   static constexpr IRQn_Type getIrqNum(PortIndex portIndex) {
   
      if (portIndex <= PortIndex::PortA) {
         constexpr IRQn_Type PortIrqs[] = PORTA_IRQS;
         return PortIrqs[0];
      }
      if (portIndex <= PortIndex::PortB) {
         constexpr IRQn_Type PortIrqs[] = PORTB_IRQS;
         return PortIrqs[0];
      }
      if (portIndex <= PortIndex::PortC) {
         constexpr IRQn_Type PortIrqs[] = PORTC_IRQS;
         return PortIrqs[0];
      }
      if (portIndex <= PortIndex::PortD) {
         constexpr IRQn_Type PortIrqs[] = PORTD_IRQS;
         return PortIrqs[0];
      }
      if (portIndex <= PortIndex::PortE) {
         constexpr IRQn_Type PortIrqs[] = PORTE_IRQS;
         return PortIrqs[0];
      }
      // INVALID_PCR, UNMAPPED_PCR, FIXED_NO_PCR
      static_assert("Illegal Port");
      return IRQn_Type(0);
   }
   
   /**
    * Check if interrupt handler has been installed
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine relevant port
    *
    * @return true if handler installed
    */
   static constexpr bool isHandlerInstalled(PinIndex pinIndex) {
      (void)pinIndex;
         if (pinIndex <= PinIndex::PTA31) {
            return false;
         }
         if (pinIndex <= PinIndex::PTB31) {
            return false;
         }
         if (pinIndex <= PinIndex::PTC31) {
            return false;
         }
         if (pinIndex <= PinIndex::PTD31) {
            return false;
         }
         if (pinIndex <= PinIndex::PTE31) {
            return false;
         }
      return false;
   }
   


   /**
    * Get PCR from pinIndex
    *
    * @param pinIndex Pin index e.g. PinIndex::PTB3. Used to determine return value
    *
    * @return Pointer to relevant PORT
    */
   static constexpr uint32_t getPcrAddress(PinIndex pinIndex){

      return getPortAddress(mapPinToPort(pinIndex)) + offsetof(PORT_Type, PCR) + sizeof(PORT_Type::PCR[0])*(int(pinIndex)%32);
   }

   /**
    * Enable clock to selected port
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine port
    */
   static inline void enablePortClock(PinIndex pinIndex) {
      SIM->SCGC5 = SIM->SCGC5 | getClockMask(pinIndex);
      __DMB();
   }

   /**
    * Disable clock to selected port
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine port
    */
   static inline void disablePortClock(PinIndex pinIndex) {
      SIM->SCGC5 = SIM->SCGC5 & ~getClockMask(pinIndex);
      __DMB();
   }

   /**
    * Translate a bitNum within a PORT/GPIO to a pinIndex
    *
    * @param basePinIndex The pinIndex for the first bit of associated PORT/GPIO e.g. PTC0
    * @param bitNum       Bit number within the PORT/GPIO
    *
    * @return  PinIndex of the bit
    */
   static constexpr PinIndex pinIndexOf(PinIndex basePinIndex, int bitNum) {
      return PinIndex(int(basePinIndex)+bitNum);
   }
};

/**
 * Common PORT features shared across all port pins
 *
 * @tparam portIndex PortIndex used to determine associated port
 */
template<PortIndex portIndex>
class PcrBase_T {

private:
   /**
    * This class is not intended to be instantiated
    */
   PcrBase_T(const PcrBase_T&) = delete;
   PcrBase_T(PcrBase_T&&) = delete;

public:

   // Empty Constructor
   constexpr PcrBase_T() = default;

#if defined(PORT_DFCR_CS_MASK)
   /// PORT hardware as pointer to struct
   static constexpr HardwarePtr<PORT_DFER_Type> port = PcrBase::getPortAddress(portIndex);
#else
   /// PORT hardware as pointer to struct
   static constexpr HardwarePtr<PORT_Type> port = PcrBase::getPortAddress(portIndex);
#endif

   /// Hardware IRQ number
   static constexpr IRQn_Type irqNum = PcrBase::getIrqNum(portIndex);

   /// Indicates if USBDM port pin interrupt handler has been installed in vector table
   static constexpr bool HANDLER_INSTALLED = PcrBase::isHandlerInstalled(mapPortToPin(portIndex));

public:

   /** Callback functions for ISRs */
   static PinCallbackFunction fCallback;

   /**
    * Interrupt handler\n
    *  - Clears interrupt flag
    *  - Calls callback
    */
   static void irqHandler() {
      // Capture interrupt flags
      uint32_t status = port->ISFR;

      // Clear flags
      port->ISFR = status;

      // Pass to call-back
      fCallback(status);
   }

   /**
    * Set callback for Pin interrupts
    *
    * @param[in] callback The function to call on Pin interrupt. \n
    *                     nullptr to indicate none
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note There is a single callback function for all pins on the related port.
    *       It is necessary to identify the originating pin in the callback
    */
   static ErrorCode setPinCallback(PinCallbackFunction callback) {

      // Always OK to remove shared handler
      if (callback == nullptr) {
         fCallback = PcrBase::unhandledCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across all port pins. Check if different callback already assigned
      if ((fCallback != PcrBase::unhandledCallback) && (fCallback != callback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      fCallback = callback;
      return E_NO_ERROR;
   }

   /**
    * Enable Pin interrupts in NVIC.
    */
   static void enableNvicPinInterrupts() {
      static_assert(irqNum>=0, "Pin does not support interrupts");
      NVIC_EnableIRQ(irqNum);
   }

   /**
    * Enable and set priority of Pin interrupts in NVIC.
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicPinInterrupts(NvicPriority nvicPriority) {
      static_assert(irqNum>=0, "Pin does not support interrupts");
      enableNvicInterrupt(irqNum, nvicPriority);
   }

   /**
    * Disable Pin interrupts in NVIC.
    */
   static void disableNvicPinInterrupts() {
      static_assert(irqNum>=0, "Pin does not support interrupts");
      NVIC_DisableIRQ(irqNum);
   }
   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PinCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::Pin<LlwuPin_0>::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Llwu::Pin<LlwuPin_0>::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t), T &object>
   static PinCallbackFunction wrapCallback() {
      static PinCallbackFunction fn = [](uint32_t status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PinCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::Pin<LlwuPin_0>::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Llwu::Pin<LlwuPin_0>::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t)>
   static PinCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static PinCallbackFunction fn = [](uint32_t status) {
         (obj.*callback)(status);
      };
      return fn;
   }
};

template<PortIndex portIndex>
PinCallbackFunction USBDM::PcrBase_T<portIndex>::fCallback = PcrBase::unhandledCallback;


/**
 * @brief Template representing a Pin Control Register (PCR)
 *
 * Code examples:
 * @code
 * // Create PCR type
 * using PortC_3 = USBDM::Pcr_T<USBDM::DEFAULT_PCR, PTC3>;
 *
 * // Configure PCR
 * PortC_3::setPCR(PinPull_Up,PinDriveStrength_High,PinDriveMode_PushPull,PinAction_None,PinFilter_None,PinSlewRate_Fast,PinMux_3);
 *
 * // Disable Port clock
 * PortC_3::disableClock();
 * @endcode
 *
 * @tparam defPcrValue           Default value for PCR (including MUX value)
 * @tparam pinIndex              Pin index e.g. PTA3
 */
template<PcrValue defPcrValue, PinIndex pinIndex>
class Pcr_T : public PcrBase_T<mapPinToPort(pinIndex)> {

protected:
   /// Default constructor used by derived classes only
   constexpr Pcr_T() {};

public:
   /// Bit number of bit being manipulated within underlying port hardware
   static constexpr int BITNUM = int(pinIndex)%32;

   /// Mask for the bit being manipulated within underlying port hardware
   static constexpr uint32_t BITMASK = makeBitMask(BITNUM);

   /// Default PCR value including PinMux value for peripheral
   static constexpr PcrInit defaultPcrValue = defPcrValue;

   /// Address of associated port
   static constexpr uint32_t portAddress = PcrBase::getPortAddress(mapPinToPort(pinIndex));

private:
   /**
    * This class is not intended to be instantiated
    */
   Pcr_T(const Pcr_T&) = delete;
   Pcr_T(Pcr_T&&) = delete;

   static constexpr HardwarePtr<uint32_t> PCR = PcrBase::getPcrAddress(pinIndex);

public:
   /**
    * Enable clock associated with PORT
    */
   static void enablePortClock() {
      if constexpr (portAddress != 0) {
         PcrBase::enablePortClock(pinIndex);
      }
   }

   /**
    * Disable clock associated with PORT
    */
   static void disablePortClock() {
      if constexpr (portAddress != 0) {
         PcrBase::disablePortClock(pinIndex);
      }
   }

   /**
    * Get Pin Control Register (PCR) value \n
    * The clock to the port will be enabled before reading the PCR
    *
    * @return pcrValue PCR value.
    */
   static uint32_t getPCR() {
      if constexpr (portAddress == 0) {
         return 0;
      }
      PcrBase::enablePortClock(pinIndex);
      return *PCR;
   }
   
   /**
    * Set Pin Control Register Attributes
    * Mux value is set appropriately for the pin function being used
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pcrValue PCR value excluding MUX value. Defaults to template value.
    */
   static void setPCR(PcrValue pcrValue=defaultPcrValue)  {
   
      if constexpr (portAddress != 0) {
         PcrBase::enablePortClock(pinIndex);
   
         uint32_t pcr  = static_cast<uint32_t>(pcrValue);
   
         // Make sure MUX value is correct
         pcr = (pcr & ~(PORT_PCR_MUX_MASK)) | defaultPcrValue.pinMux();
   
         // Set PCR register for pin
         *PCR = pcr;
      }
   }

   /**
    * Set Pin Control Register Attributes
    * Mux value is set appropriately for the pin function being used
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pcrInit PCR value excluding MUX value. Defaults to template value.
    */
   static void setPCR(const PcrInit &pcrInit)  {
   
      if constexpr (portAddress != 0) {
         PcrBase::enablePortClock(pinIndex);
   
         uint32_t pcr  = static_cast<uint32_t>(pcrInit.value);
   
         // Make sure MUX value is correct
         pcr = (pcr & ~(PORT_PCR_MUX_MASK)) | defaultPcrValue.pinMux();
   
         // Set PCR register for pin
         *PCR = pcr;
      }
   }

   /**
    * Set Pin Control Register Attributes
    * Parameters default to values appropriate for the pin function being used.
    * The clock to the port will be enabled before changing the PCR
    *
    * @param pinPull          Pin pull device (up/down/none) on digital inputs
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinAction        DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter        Pin filtering on digital inputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    * @param pinMux           Which function is mapped to the pin
    */
   static void setPCR(
         PinPull          pinPull,
         PinDriveStrength pinDriveStrength = PinDriveStrength_Low,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinAction        pinAction        = PinAction_None,
         PinFilter        pinFilter        = PinFilter_None,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast,
         PinMux           pinMux           = PinMux_Analogue)  {
   
      if constexpr (portAddress != 0) {
         PcrBase::enablePortClock(pinIndex);
   
         // Set PCR register for pin
         *PCR = pinPull|pinDriveStrength|pinDriveMode|pinAction|pinFilter|pinSlewRate|pinMux;
      }
   }

   /**
    * @brief
    * Set the Pin Control Register Attributes to the default values determined by Configure.usbdmProject.
    * Mux value is set appropriately for the pin function being used.
    * The clock to the port will be enabled before changing the PCR.
    */
   static void setOutput() {
      setPCR(defaultPcrValue.value);
   }

   /**
    * @brief
    * Set the Pin Control Register Attributes
    * Mux value is set appropriately for the pin function being used.
    * The clock to the port will be enabled before changing the PCR.
    */
   static void setOutput(PcrValue pcrValue) {
      setPCR(pcrValue);
   }

   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction
    *
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * The clock to the port will be enabled before changing the PCR.
    *
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    */
   static void setOutput(
         PinDriveStrength pinDriveStrength,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast)  {
   
      setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /**
    * @brief
    * Set the Pin Control Register Attributes to the default values determined by Configure.usbdmProject.
    * Mux value is set appropriately for the pin function being used.
    * The clock to the port will be enabled before changing the PCR.
    */
   static void setInput() {
   
      setPCR(defaultPcrValue.value);
   }
   
   /**
    * @brief
    * Set the Pin Control Register Attributes
    * Mux value is set appropriately for the pin function being used.
    * The clock to the port will be enabled before changing the PCR.
    */
   static void setInput(PcrValue pcrValue) {
   
      setPCR(pcrValue);
   }
   
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with input direction
    *
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * The clock to the port will be enabled before changing the PCR.
    *
    * @param pinPull   Pin pull device (up/down/none) on digital inputs
    * @param pinAction DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter Pin filtering on digital inputs
    */
   static void setInput(
         PinPull   pinPull,
         PinAction pinAction = PinAction_None,
         PinFilter pinFilter = PinFilter_None)  {
   
      setPCR(pinPull|pinAction|pinFilter);
   }

   /**
    * Set Pin pull device
    *
    * pinPull Pin pull device (up/down/none) on digital inputs
    */
   static void setPcrOption(PinPull pinPull)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_PD_MASK)|pinPull;
      }
   }
   /**
    * Set Pin input filter
    *
    * pinFilter Pin filtering on digital inputs
    */
   static void setPcrOption(PinFilter pinFilter)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_PFE_MASK)|pinFilter;
      }
   }
   /**
    * Set Pin drive strength
    *
    * pinDriveStrength Pin drive strength of digital outputs
    */
   static void setPcrOption(PinDriveStrength pinDriveStrength)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_DSE_MASK)|pinDriveStrength;
      }
   }
   /**
    * Set Pin drive mode
    *
    * pinDriveMode Pin drive mode (push-pull/open-drain) of digital outputs
    */
   static void setPcrOption(PinDriveMode pinDriveMode)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_ODE_MASK)|pinDriveMode;
      }
   }
   /**
    * Set Pin slew rate
    *
    * pinSlewRate Pin slew rate of digital outputs
    */
   static void setPcrOption(PinSlewRate pinSlewRate)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_SRE_MASK)|pinSlewRate;
      }
   }
   /**
    * Set Pin Control Register (PCR) lock
    *
    * pinLock Prevents modification of some of the PCR values once set
    */
   static void setPcrOption(PinLock pinLock)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_LK_MASK)|pinLock;
      }
   }
   /**
    * Set Pin interrupt/DMA actions
    *
    * pinAction DMA and/or interrupt actions to happen on pin change or level
    */
   static void setPcrOption(PinAction pinAction)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_IRQC_MASK)|pinAction;
      }
   }
   /**
    * Set Pin Multiplexor setting
    *
    * pinMux Which function is mapped to the pin
    */
   static void setPcrOption(PinMux pinMux)  {
   
      if constexpr (portAddress != 0) {
         *PCR = (*PCR & ~PORT_PCR_MUX_MASK)|pinMux;
      }
   }

   /**
    *  Disable Pin
    *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
    *
    *  @note The clock is left enabled as shared with other pins.
    *  @note Mux(0) is also the Analogue MUX setting
    */
   static void disablePin() {
      if constexpr (portAddress != 0) {
         enablePortClock();
         setPcrOption(PinMux_Disabled);
      }
   }

   /**
    * Clear pin interrupt flag.
    * Assumes clock to the port has already been enabled.
    */
   static void clearPinInterruptFlag() {
      if constexpr (portAddress != 0) {
         *PCR = *PCR | PORT_PCR_ISF_MASK;
      }
   }

#ifdef PORT_DFCR_CS_MASK
   /**
    * Configures Digital Pin Filter
    *
    * @param pinDigitalFilterClock  Clock source
    * @param filterLength           Filter length in clock ticks
    *
    * @note Not all ports support this feature
    * @note This affects the digital filter for all pins of this port
    */
   static void configureDigitalPinFilter(PinDigitalFilterClock pinDigitalFilterClock, int filterLength) {
      if constexpr (portAddress != 0) {
         // Disable all filtering before change
         uint32_t dfer = Pcr_T::port->DFER;
         Pcr_T::port->DFER = 0;

         Pcr_T::port->DFCR = pinDigitalFilterClock;
         Pcr_T::port->DFWR = PORT_DFWR_FILT(filterLength);

         // Restore filtering on pins
         Pcr_T::port->DFER = dfer;
      }
   }

   /**
    * Enable digital filter on the pin
    *
    * @note Not all ports support this feature
    */
   static void enableDigitalPinFilter() {
      if constexpr (portAddress != 0) {
         Pcr_T::port->DFER = Pcr_T::port->DFER | BITMASK;
      }
   }

   /**
    * Disable digital filter on the pin
    *
    * @note Not all ports support this feature
    */
   static void disableDigitalPinFilter() {
      if constexpr (portAddress != 0) {
         Pcr_T::port->DFER = Pcr_T::port->DFER & ~BITMASK;
      }
   }
#endif

};

/**
 * @brief Template function to set a PCR to the default value
 *
 * @tparam  Last PCR to modify
 */
template<typename Last>
void processPcrs() {
   Last::setPCR();
}
/**
 * @brief Template function to set a collection of PCRs to the default value
 *
 * @tparam  Pcr1 PCR to modify
 * @tparam  Pcr2 PCR to modify
 * @tparam  Rest Remaining PCRs to modify
 */
template<typename Pcr1, typename  Pcr2, typename  ... Rest>
void processPcrs() {
   processPcrs<Pcr1>();
   processPcrs<Pcr2, Rest...>();
}
/**
 * @brief Template function to set a PCR to a given value
 *
 * @param[in]   pcrValue PCR value to set
 *
 * @tparam  Last PCR to modify
 */
template<typename Last>
void processPcrs(uint32_t pcrValue) {
   Last::setPCR(pcrValue);
}

/**
 * @brief Template function to set a collection of PCRs to a given value
 *
 * @param[in] pcrValue PCR value to set
 *
 * @tparam  Pcr1 PCR to modify
 * @tparam  Pcr2 PCR to modify
 * @tparam  Rest Remaining PCRs to modify
 */
template<typename Pcr1, typename  Pcr2, typename  ... Rest>
void processPcrs(uint32_t pcrValue) {
   processPcrs<Pcr1>(pcrValue);
   processPcrs<Pcr2, Rest...>(pcrValue);
}

/**
 * @brief Template representing a Pin Control Register (PCR)\n
 * Makes use of an info[] table in a configuration class
 *
 * Code examples:
 * @code
 * // Create PCR type
 * PcrTable_T<spiInfo, 3> SpiMOSI;
 *
 * // Configure PCR
 * SpiMOSI::setPCR(PinPull_Up,PinDriveStrength_High,PinDriveMode_PushPull,PinAction_None,PinFilter_None,PinSlewRate_Fast,PinMux_3);
 *
 * // Disable clock to associated PORT
 * SpiMOSI::disableClock();
 *
 * // Alternatively the PCR may be manipulated directly
 * Pcr_T<spiInfo, 3>::setPCR(PORT_PCR_DSE_MASK|PORT_PCR_PE_MASK|PORT_PCR_PS_MASK);
 * @endcode
 *
 * @tparam info          Configuration class
 * @tparam index         Index of pin in configuration table within class
 */
template<class Info, uint8_t index>
class PcrTable_T : public Pcr_T<Info::info[index].pcrValue, Info::info[index].pinIndex> {
};
/**
 * @}
 ** PeripheralPinTables
 */

#endif // PORT_PCR_MUX_MASK

#if defined(RELEASE_BUILD)
// MACRO to do OR operation
#define USBDM_PCR_OR(...) USBDM_CONCAT(USBDM_OR, USBDM_COUNT_ARGUMENTS(__VA_ARGS__))(__VA_ARGS__)
#define USBDM_OR0()
#define USBDM_OR1(a)           (PcrValue)(a)
#define USBDM_OR2(a,b)         (PcrValue)(a|b)
#define USBDM_OR3(a,b,c)       (PcrValue)(a|b|c)
#define USBDM_OR4(a,b,c,d)     (PcrValue)(a|b|c|d)
#define USBDM_OR5(a,b,c,d,e)   (PcrValue)(a|b|c|d|e)
#define USBDM_OR6(a,b,c,d,e,f) (PcrValue)(a|b|c|d|e|f)
#endif

#pragma GCC pop_options

} // End namespace USBDM

#endif /* HEADER_PCR_H */

