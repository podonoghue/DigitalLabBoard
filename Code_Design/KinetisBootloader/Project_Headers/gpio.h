/**
 * @file     gpio.h (180.ARM_Peripherals/Project_Headers/gpio.h)
 * @brief    General Purpose Input/Output
 *
 * @version  V4.12.1.300
 * @date     7 July 2022
 */

#ifndef HEADER_GPIO_H
#define HEADER_GPIO_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include "derivative.h"
#ifdef RELEASE_BUILD
#include "bitband.h"
#endif

/*
 * Default port information
 */
#ifndef FIXED_PORT_CLOCK_REG
#define FIXED_PORT_CLOCK_REG SCGC5
#endif

namespace USBDM {

#pragma GCC push_options
#pragma GCC optimize ("Os")

/**
 * Class representing GPIO functionality
 */
class Gpio {

   /**
    * This class is not intended to be instantiated by copy
    */
   Gpio(const Gpio&) = delete;
   Gpio(Gpio&&) = delete;

public:
   /// Underlying GPIO hardware
   const    HardwarePtr<GPIO_Type>     gpio;

   /// Mask for GPIO bit being manipulated
   const    uint32_t                   bitMask;

   /// Mask to flip bit if active low (0 otherwise)
   const    uint32_t                   flipMask;

protected:
   /**
    * Class representing GPIO functionality
    *
    * @param gpio       GPIO hardware address
    * @param bitNo      Bit number within GPIO
    * @param polarity   Polarity of bit (ActiveHigh or ActiveLow)
    */
   constexpr Gpio(uint32_t gpio, uint8_t bitNo, Polarity polarity) :
      gpio(gpio), bitMask(1<<bitNo), flipMask(isActiveLow(polarity)?bitMask:0) {
   }

   /**
    * Checks if polarity if active-low
    */
   static constexpr bool isActiveLow(Polarity polarity) {
      return (polarity == ActiveLow);
   }

   /**
    * Checks if polarity if active-high
    */
   static constexpr bool isActiveHigh(Polarity polarity) {
      return (polarity == ActiveHigh);
   }

public:
   /**
    * Get default PCR value for a pin
    *
    * @param pinIndx Pin index e.g. PTB3.
    *
    * @return PCR value determined by Configure.usbdm setting
    */
   static constexpr PcrValue GpioPcrValue(PinIndex pinIndx) {
      (void)pinIndx;
      if (pinIndx <= PinIndex::PTA31) {
         return GpioAInfo::info[int(pinIndx)-int(PinIndex::PTA0)].pcrValue;
      }
      if (pinIndx <= PinIndex::PTB31) {
         return GpioBInfo::info[int(pinIndx)-int(PinIndex::PTB0)].pcrValue;
      }
      if (pinIndx <= PinIndex::PTC31) {
         return GpioCInfo::info[int(pinIndx)-int(PinIndex::PTC0)].pcrValue;
      }
      if (pinIndx <= PinIndex::PTD31) {
         return GpioDInfo::info[int(pinIndx)-int(PinIndex::PTD0)].pcrValue;
      }
      if (pinIndx <= PinIndex::PTE31) {
         return GpioEInfo::info[int(pinIndx)-int(PinIndex::PTE0)].pcrValue;
      }
      return PcrValue(0);
   }
   
   /**
    * Get GPIO from pinIndex
    *
    * @param pinIndex PinIndex Used to determine return value
    *
    * @return Pointer to relevant GPIO
    */
   static constexpr uint32_t getGpioAddress(PinIndex pinIndex ){
      if (pinIndex < PinIndex::MIN_PIN_INDEX) {
         // INVALID_PCR, UNMAPPED_PCR, FIXED_NO_PCR
         return 0;
      }
      if (pinIndex <= PinIndex::PTA31) {
         return GPIOA_BasePtr;
      }
      if (pinIndex <= PinIndex::PTB31) {
         return GPIOB_BasePtr;
      }
      if (pinIndex <= PinIndex::PTC31) {
         return GPIOC_BasePtr;
      }
      if (pinIndex <= PinIndex::PTD31) {
         return GPIOD_BasePtr;
      }
      if (pinIndex <= PinIndex::PTE31) {
         return GPIOE_BasePtr;
      }
       static_assert("Illegal Port");
       return 0;
   }
   

   /**
    * Set pin as digital input
    *
    * @note Does not affect other pin settings
    */
   void setIn() const {
      // Make pin an input
      gpio->PDDR = gpio->PDDR & ~bitMask;
   }
   /**
    * Set pin as digital output
    *
    * @note Does not affect other pin settings
    */
   void setOut() const {
      // Make pin an output
      gpio->PDDR = gpio->PDDR | bitMask;
   }
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   void high() const {
      gpio->PSOR = bitMask;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   void low() const {
      gpio->PCOR = bitMask;
   }
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   void set() const {
      gpio->PSOR = bitMask;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   void clear() const {
      gpio->PCOR = bitMask;
   }
   /**
    * Toggle pin (if output)
    */
   void toggle() const {
      gpio->PTOR = bitMask;
   }
   /**
    * Read pin value
    *
    * @return true/false reflecting pin value.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   bool readBit() const {
      return isHigh();
   }
   /**
    * Write boolean value to pin (if configured as output)
    *
    * @param[in] value true/false value
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   void  __attribute__((always_inline)) writeBit(bool value) const {
      if (value) {
         set();
      }
      else {
         clear();
      }
   }
   /**
    * Set pin to active level (if configured as output)
    *
    * @note Polarity _is_ significant
    *
    * ActiveHigh: bm = 1, fm = 0 PSOR <- 1 = bm^fm, PCOR <- 0 = fm
    * ActiveLow:  bm = 1, fm = 1 PSOR <- 0 = bm^fm, PCOR <- 1 = fm
    */
   void setActive() const {
      gpio->PSOR = bitMask^flipMask;
      gpio->PCOR = flipMask;
   }
   /**
    * Set pin to inactive level (if configured as output)
    *
    * @note Polarity _is_ significant
    *
    * ActiveHigh: bm = 1, fm = 0 PSOR <- 0 = fm, PCOR <- 1 = bm^fm
    * ActiveLow:  bm = 1, fm = 1 PSOR <- 1 = fm, PCOR <- 0 = bm^fm
    */
   void setInactive() const {
      gpio->PSOR = flipMask;
      gpio->PCOR = bitMask^flipMask;
   }
   /**
    * Set pin to active level (if configured as output).
    * Convenience method for setActive()
    *
    * @note Polarity _is_ significant
    */
   void __attribute__((always_inline)) on() const {
      setActive();
   }
   /**
    * Set pin to inactive level (if configured as output).
    * Convenience method for setInactive()
    *
    * @note Polarity _is_ significant
    */
   void __attribute__((always_inline)) off() const {
      setInactive();
   }
   /**
    * Write boolean value to pin (if configured as output)
    *
    * @param[in] value true/false value
    *
    * @note Polarity _is_ significant
    */
   void write(bool value) const {
      if (value) {
         setActive();
      }
      else {
         setInactive();
      }
   }
   /**
    * Checks if pin is high
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   bool isHigh() const {
      return (gpio->PDIR & bitMask) != 0;
   }
   /**
    * Checks if pin is low
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   bool isLow() const {
      return (gpio->PDIR & bitMask) == 0;
   }
   /**
    * Read pin value
    *
    * @return true/false reflecting pin value.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   bool read() const {
      return ((gpio->PDIR^flipMask) & bitMask) != 0;
   }
   /**
    * Read value being driven to pin (if configured as output)
    *
    * @return true/false reflecting value in output register.
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   bool readState() const {
      return ((gpio->PDOR^flipMask) & bitMask) != 0;
   }
   /**
    * Read pin value and return true if active level.
    * Equivalent to read()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   bool __attribute__((always_inline)) isActive() const {
      return read();
   }
   /**
    * Read pin value and return true if inactive level
    * Equivalent to !read()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   bool __attribute__((always_inline)) isInactive() const {
      return !read();
   }
   /**
    * Read pin value and return true if active level.\n
    * Convenience method equivalent to isActive()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   bool __attribute__((always_inline)) isPressed() const {
      return isActive();
   }
   /**
    * Read pin value and return true if inactive level.\n
    * Convenience method equivalent to isInactive()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   bool __attribute__((always_inline)) isReleased() const {
      return isInactive();
   }
};

/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief General Purpose Input/Output
 * @{
 */

/**
 * @brief Template representing a pin with Digital I/O capability
 *
 * <b>Example</b>
 * @code
 * // Instantiate
 * using Pta3 = USBDM::Gpio_T<SIM_SCGC5_PORTA_MASK, PORTA_BasePtr, PORTA_IRQn, GPIOA_BasePtr, 3, ActiveHigh>;
 *
 * // Set as digital output
 * Pta3::setOutput();
 *
 * // Set pin high
 * Pta3::set();
 *
 * // Set pin low
 * Pta3::clear();
 *
 * // Toggle pin
 * Pta3::toggle();
 *
 * // Set pin to boolean value
 * Pta3::write(true);
 *
 * // Set pin to boolean value
 * Pta3::write(false);
 *
 * // Set as digital input
 * Pta3::setInput();
 *
 * // Read pin as boolean value
 * bool x = Pta3::read();
 *
 * @endcode
 *
 *
 * @tparam defPcrValue           Default value for PCR (excluding MUX value which is forced to GPIO)
 * @tparam defaultNvicPriority   Default interrupt priority.\n
 *                               NvicPriority_NotInstalled indicates PORT not configured for interrupts.
 * @tparam pinIndex              Pin index used to locate PORT/GPIO and bit position
 * @tparam polarity              Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<PcrValue defPcrValue, PinIndex pinIndex, Polarity polarity>
class Gpio_T : public Gpio, public Pcr_T<gpioPcrValue(defPcrValue), pinIndex> {

   static constexpr int bitNum = int(pinIndex) % 32;

//      PcrBase::CheckPinExistsAndIsMapped<bitNum> check;
   static_assert((static_cast<unsigned>(bitNum)<=31), "Illegal bit number in Gpio");

private:
   /**
    * This class is not intended to be instantiated
    */
   Gpio_T(const Gpio_T&) = delete;
   Gpio_T(Gpio_T&&) = delete;
protected:
   constexpr Gpio_T() : Gpio(gpioAddress, bitNum, polarity) {};

public:
   static constexpr PcrInit defaultPcrValue = gpioPcrValue(defPcrValue);

   /// GPIO hardware address
   static constexpr uint32_t gpioAddress = Gpio::getGpioAddress(pinIndex);

   /** PCR associated with this GPIO pin */
   using Pcr = Pcr_T<defaultPcrValue, pinIndex>;

   /** Get base address of GPIO hardware as pointer to struct */
   static constexpr HardwarePtr<GPIO_Type> gpio = gpioAddress;

   /// Base address of GPIO hardware
   static constexpr uint32_t gpioBase = gpioAddress;
   /// Address of PDOR register in GPIO
   static constexpr uint32_t gpioPDOR = gpioAddress+offsetof(GPIO_Type, PDOR);
   /// Address of PSOR register in GPIO
   static constexpr uint32_t gpioPSOR = gpioAddress+offsetof(GPIO_Type, PSOR);
   /// Address of PCOR register in GPIO
   static constexpr uint32_t gpioPCOR = gpioAddress+offsetof(GPIO_Type, PCOR);
   /// Address of PTOR register in GPIO
   static constexpr uint32_t gpioPTOR = gpioAddress+offsetof(GPIO_Type, PTOR);
   /// Address of PDDR register in GPIO
   static constexpr uint32_t gpioPDDR = gpioAddress+offsetof(GPIO_Type, PDDR);
   /// Address of PDIR register in GPIO
   static constexpr uint32_t gpioPDIR = gpioAddress+offsetof(GPIO_Type, PDIR);

   /** Polarity of pin */
   static constexpr Polarity POLARITY = polarity;

   /**
    * Set pin as digital I/O.
    * Pin is initially set as an input.
    * Use SetIn() and SetOut() to change direction.
    *
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pcrValue PCR value to use in configuring pin (excluding MUX value). See pcrValue()
    */
   static void setInOut() {
      // Make input initially
      setIn();
      // Set inactive pin state (if later made output)
      setInactive();
      Pcr::setPCR(defaultPcrValue.value);
   }
   /**
    * Set pin as digital I/O.
    * Pin is initially set as an input.
    * Use SetIn() and SetOut() to change direction.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pcrInit PCR value to use in configuring pin (excluding MUX value). See pcrValue()
    */
   static void setInOut(const PcrInit &pcrInit) {
      // Make input initially
      setIn();
      // Set inactive pin state (if later made output)
      setInactive();
      // Configure PCR
      Pcr::setPCR(pcrInit.value);
   }

   /**
    * Set pin as digital I/O.
    * Pin is initially set as an input.
    * Use SetIn() and SetOut() to change direction.
    * If open-drain then input function may meaningfully be used while set as output
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param pinPull          Pin pull device (up/down/none) on digital inputs
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinAction        DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter        Pin filtering on digital inputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    */
   static void setInOut(
         PinPull          pinPull,
         PinDriveStrength pinDriveStrength = PinDriveStrength_Low,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinAction        pinAction        = PinAction_None,
         PinFilter        pinFilter        = PinFilter_None,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast)  {
   
      // Make input initially
      setIn();
      // Set inactive pin state (if later made output)
      setInactive();
      // Configure PCR
      Pcr::setPCR(pinPull|pinDriveStrength|pinDriveMode|pinAction|pinFilter|pinSlewRate);
   }
   
   /**
    * Set pin as digital output
    *
    * @note Does not affect other pin settings
    */
   static void setOut() {
      // Make pin an output
#ifdef RELEASE_BUILD
      bitbandSet(gpio->PDDR, bitNum);
#else
      gpio->PDDR = gpio->PDDR | Pcr::BITMASK;
#endif
   }

   /**
    * Enable pin as digital output with initial inactive level.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut() for a lightweight change of direction without affecting other pin settings.
    * @note PCR value is taken from the value set in Configure.usbdmProject
    */
   static void setOutput() {
      // Set initial level before enabling pin drive
      setInactive();
      // Make pin an output
      setOut();
      // Configure pin
      Pcr::setPCR(defaultPcrValue.value);
   }

   /**
    * Enable pin as digital output with initial inactive level.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrInit PCR value to use in configuring port (excluding MUX value). See pcrValue()
    */
   static void setOutput(const PcrInit &pcrInit) {
      // Set initial level before enabling pin drive
      setInactive();
      // Make pin an output
      setOut();
      // Configure pin
      Pcr::setPCR(pcrInit.value);
   }

   /**
    * @brief
    * Enable pin as digital output with initial inactive level
    * Configures <b>all</b> Pin Control Register (PCR) values

    * Unreferenced fields are cleared.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut() for a lightweight change of direction without affecting other pin settings.
    *
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    */
   static void setOutput(
         PinDriveStrength pinDriveStrength,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast)  {
   
      // Set initial level before enabling pin drive
      setInactive();
      // Make pin an output
      setOut();
      // Configure PCR
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }
   
   /**
    * Set pin as digital input
    *
    * @note Does not affect other pin settings
    */
   static void setIn() {
      // Make pin an input
#ifdef RELEASE_BUILD
      bitbandClear(gpio->PDDR, bitNum);
#else
      gpio->PDDR = gpio->PDDR & ~Pcr::BITMASK;
#endif
   }
   /**
    * @brief
    * Enable pin as digital input.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    * @note PCR value is taken from the value set in Configure.usbdmProject
    */
   static void setInput() {
      // Make pin an input
      setIn();
      // Configure pin
      Pcr::setPCR(defaultPcrValue.value);
   }

   /**
    * @brief
    * Enable pin as digital input.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrInit PCR value to use in configuring port (excluding MUX value)
    */
   static void setInput(const PcrInit &pcrInit) {
      // Make pin an input
      setIn();
      // Configure pin
      Pcr::setPCR(pcrInit.value);
   }

   /**
    * Enable pin as digital input.
    * Configures <b>all</b> Pin Control Register (PCR) values
    * Unreferenced fields are cleared.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    *
    * @param pinPull   Pin pull device (up/down/none) on digital inputs
    * @param pinAction DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter Pin filtering on digital inputs
    */
   static void setInput(
         PinPull   pinPull,
         PinAction pinAction = PinAction_None,
         PinFilter pinFilter = PinFilter_None)  {
   
      // Make input
      setIn();
      // Configure PCR
      Pcr::setPCR(pinPull|pinAction|pinFilter);
   }
   
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void high() {
      gpio->PSOR = Pcr::BITMASK;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void low() {
      gpio->PCOR = Pcr::BITMASK;
   }
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void set() {
      gpio->PSOR = Pcr::BITMASK;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void clear() {
      gpio->PCOR = Pcr::BITMASK;
   }
   /**
    * Toggle pin (if output)
    */
   static void toggle() {
      gpio->PTOR = Pcr::BITMASK;
   }
   /**
    * Write boolean value to pin (if configured as output)
    *
    * @param[in] value true/false value
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void  __attribute__((always_inline)) writeBit(bool value) {
      if (value) {
         set();
      }
      else {
         clear();
      }
   }
   /**
    * Read pin value
    *
    * @return true/false reflecting pin value.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static bool readBit() {
      return isHigh();
   }
   /**
    * Set pin to active level (if configured as output)
    *
    * @note Polarity _is_ significant
    */
   static void setActive() {
      if constexpr (isActiveLow(polarity)) {
         clear();
      }
      else {
         set();
      }
   }
   /**
    * Set pin to inactive level (if configured as output)
    *
    * @note Polarity _is_ significant
    */
   static void setInactive() {
      if constexpr (isActiveLow(polarity)) {
         set();
      }
      else {
         clear();
      }
   }
   /**
    * Set pin to active level (if configured as output).
    * Convenience method for setActive()
    *
    * @note Polarity _is_ significant
    */
   static void __attribute__((always_inline)) on() {
      setActive();
   }
   /**
    * Set pin to inactive level (if configured as output).
    * Convenience method for setInactive()
    *
    * @note Polarity _is_ significant
    */
   static void __attribute__((always_inline)) off() {
      setInactive();
   }
   /**
    * Write boolean value to pin (if configured as output)
    *
    * @param[in] value true/false value
    *
    * @note Polarity _is_ significant
    */
   static void write(bool value) {
#ifdef RELEASE_BUILD
      if constexpr (isActiveLow(polarity)) {
         bitbandWrite(gpio->PDOR, bitNum, !value);
      }
      else {
         bitbandWrite(gpio->PDOR, bitNum, value);
      }
#else
      if (value) {
         setActive();
      }
      else {
         setInactive();
      }
#endif
   }
   /**
    * Checks if pin is high
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   static bool isHigh() {
      return (gpio->PDIR & Pcr::BITMASK) != 0;
   }
   /**
    * Checks if pin is low
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   static bool isLow() {
      return (gpio->PDIR & Pcr::BITMASK) == 0;
   }
   /**
    * Read pin value
    *
    * @return true/false reflecting pin value.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool read() {
      if constexpr (isActiveLow(polarity)) {
         return isLow();
      }
      else {
         return isHigh();
      }
   }
   /**
    * Read pin value and return true if active level.
    * Equivalent to read()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isActive() {
      return read();
   }
   /**
    * Read pin value and return true if inactive level
    * Equivalent to !read()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isInactive() {
      return !read();
   }
   /**
    * Read pin value and return true if active level.\n
    * Convenience method equivalent to isActive()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isPressed() {
      return isActive();
   }
   /**
    * Read pin value and return true if inactive level.\n
    * Convenience method equivalent to isInactive()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isReleased() {
      return isInactive();
   }
   /**
    * Read value being driven to pin (if configured as output)
    *
    * @return true/false reflecting value in output register.
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   static bool readState() {
      uint32_t t = gpio->PDOR & Pcr::BITMASK;
      if constexpr (isActiveLow(polarity)) {
         return !t;
      }
      else {
         return t;
      }
   }
};

/**
 * Class representing GPIO field functionality
 */
class GpioField {

public:
   /// Underlying GPIO hardware
   const HardwarePtr<GPIO_Type>  gpio;

   /// Mask for GPIO bits being manipulated
   const uint32_t                bitMask;

   /// Mask to flip bit values if active low (0 otherwise)
   const uint32_t                flipMask;

   /// Offset of bit field in GPIO hardware
   const uint8_t                 right;

protected:
   /**
    * Class representing GPIO field functionality
    *
    * @param gpio       GPIO hardware address
    * @param bitMask    Bitmask for bits affected in port
    * @param right      Rightmost bit number in port
    * @param flipMask   Mask to flip bits in port (or use ActiveHigh/ActiveLow)
    */
   constexpr GpioField(uint32_t gpio, uint32_t bitMask, unsigned right, uint32_t flipMask) :
      gpio(gpio), bitMask(bitMask), flipMask(flipMask), right(right) {
   }

public:
   /**
    * Set all pins in field as inputs.
    *
    * @note Does not affect other pin settings.
    */
   void setIn() const {
      gpio->PDDR = gpio->PDDR & ~bitMask;
   }
   /**
    * Set all pins in field as outputs.
    *
    * @note Does not affect other pin settings.
    */
   void setOut() const {
      gpio->PDDR = gpio->PDDR | bitMask;
   }
   /**
    * Set individual pin directions
    *
    * @param[in] mask Mask for pin directions (1=>out, 0=>in)
    *
    * @note Does not affect other pin settings.
    */
   void setDirection(uint32_t mask) const {
      USBDM::CriticalSection cs;
      gpio->PDDR = (gpio->PDDR&~bitMask)|((mask<<right)&bitMask);
   }
   /**
    * Set bits in field output register
    *
    * @param[in] mask Mask to apply to the field (1 => set bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   void bitSet(const uint32_t mask) const {
      gpio->PSOR = (mask<<right)&bitMask;
   }
   /**
    * Clear bits in field output register
    *
    * @param[in] mask Mask to apply to the field (1 => clear bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   void bitClear(const uint32_t mask) const {
      gpio->PCOR = (mask<<right)&bitMask;
   }
   /**
    * Toggle bits in field output register
    *
    * @param[in] mask Mask to apply to the field (1 => toggle bit, 0 => unchanged)
    */
   void bitToggle(const uint32_t mask) const {
      gpio->PTOR = (mask<<right)&bitMask;
   }
   /**
    * Read field as unmodified bit field
    *
    * @return Value from field pins
    *
    * @note Polarity _is_ _not_ significant
    */
   uint32_t bitRead() const {
      return (gpio->PDIR & bitMask)>>right;
   }
   /**
    * Read field
    *
    * @return value from field pins
    *
    * @note Polarity _is_ significant
    */
   uint32_t read() const {
      return ((gpio->PDIR^flipMask)&bitMask)>>right;
   }
   /**
    * Read value being driven to field pins (if configured as output)
    *
    * @return value from field output register
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   bool readState() const {
      return ((gpio->PDOR^flipMask)&bitMask)>>right;
   }
   /**
    * Write field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ significant
    */
   void write(uint32_t value) const {
      {
         USBDM::CriticalSection cs;
         gpio->PDOR = ((gpio->PDOR) & ~bitMask) | (((value<<right)^flipMask)&bitMask);
      }
   }

   /**
    * Write bit field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ _not_ significant
    */
   void bitWrite(uint32_t value) const {
      USBDM::CriticalSection cs;
      gpio->PDOR = ((gpio->PDOR) & ~bitMask) | ((value<<right)&bitMask);
   }
};

/**
 * Create GPIO from Peripheral Info class info table
 *
 * @tparam Info          Peripheral information class
 * @tparam index         Index of signal within the info table
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<class Info, const uint32_t index, Polarity polarity>
class GpioTable_T : public Gpio_T<Info::info[index].pcrValue, Info::info[index].pinIndex, polarity> {};
/**
 * @brief Template representing a field within a port
 *
 * <b>Example</b>
 * @code
 * // Instantiate object representing Port A 6 down to 3
 * using Pta6_3 = GpioField_T<GpioAInfo, 6, 3>;
 *
 * // Set as digital output
 * Pta6_3::setOutput();
 *
 * // Write value to field
 * Pta6_3::write(0x53);
 *
 * // Clear all of field
 * Pta6_3::bitClear();
 *
 * // Clear lower two bits of field
 * Pta6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * Pta6_3::bitSet(0x3);
 *
 * // Set as digital input
 * Pta6_3::setInput();
 *
 * // Read pin as int value
 * int x = Pta6_3::read();
 * @endcode
 *
 * @tparam defPcrValue          Default value for PCR (excluding MUX value which is forced to GPIO)
 * @tparam irqLevel             Default interrupt priority.\n
 *                              NvicPriority_NotInstalled indicates PORT not configured for interrupts.
 * @tparam left                 Bit number of leftmost bit in GPIO (inclusive)
 * @tparam right                Bit number of rightmost bit in GPIO (inclusive)
 * @tparam FlipMask             Polarity of all bits in field. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
 */
template<PcrValue defPcrValue, PinIndex Left, PinIndex Right, Polarity FlipMask=ActiveHigh>
class GpioField_T : public GpioField, public PcrBase_T<mapPinToPort(Left)>{

private:
   /**
    * This class is not intended to be instantiated
    */
   GpioField_T(const GpioField_T&) = delete;
   GpioField_T(GpioField_T&&) = delete;
   static constexpr PcrInit defaultPcrValue = gpioPcrValue(defPcrValue);

   static_assert((Left>=Right), "left must be >= right in GpioField");

public:
   static constexpr uint32_t gpioAddress = Gpio::getGpioAddress(Left);

//   constexpr GpioField_T() : GpioField(gpioAddress, BITMASK, Right, FLIP_MASK) {}

   /** Get base address of GPIO hardware as pointer to struct */
   static constexpr HardwarePtr<GPIO_Type> gpio = Gpio::getGpioAddress(Left);

   /// Base address of GPIO hardware
   static constexpr uint32_t gpioBase = gpioAddress;
   /// Address of PDOR register in GPIO
   static constexpr uint32_t gpioPDOR = gpioAddress+offsetof(GPIO_Type, PDOR);
   /// Address of PSOR register in GPIO
   static constexpr uint32_t gpioPSOR = gpioAddress+offsetof(GPIO_Type, PSOR);
   /// Address of PCOR register in GPIO
   static constexpr uint32_t gpioPCOR = gpioAddress+offsetof(GPIO_Type, PCOR);
   /// Address of PTOR register in GPIO
   static constexpr uint32_t gpioPTOR = gpioAddress+offsetof(GPIO_Type, PTOR);
   /// Address of PDDR register in GPIO
   static constexpr uint32_t gpioPDDR = gpioAddress+offsetof(GPIO_Type, PDDR);
   /// Address of PDIR register in GPIO
   static constexpr uint32_t gpioPDIR = gpioAddress+offsetof(GPIO_Type, PDIR);

public:
   /** Port associated with this GPIO Field */
   using Port = PcrBase_T<mapPinToPort(Left)>;

   /** Bit number of left bit within underlying port hardware */
   static constexpr unsigned LEFT = int(Left)%32;

   /** Bit number of right bit within underlying port hardware */
   static constexpr unsigned RIGHT = int(Right)%32;

   static_assert((LEFT>=RIGHT), "left and right are not in same port in GpioField");

   /** Mask for the bits being manipulated within underlying port hardware */
   static constexpr uint32_t BITMASK = static_cast<uint32_t>((1ULL<<(LEFT-RIGHT+1))-1)<<RIGHT;

   /** Mask to flip bits in field. Two special cases for later optimisation */
   static constexpr uint32_t FLIP_MASK =
         (((FlipMask<<RIGHT)&BITMASK)==BITMASK)?0xFFFFFFFFUL:  // All active-low
         (((FlipMask<<RIGHT)&BITMASK)==0)?0x00000000UL:        // All active-high
         (FlipMask<<RIGHT);                                    // Mixed

   static_assert((FlipMask==0xFFFFFFFFUL)||((((FlipMask<<RIGHT)&BITMASK)>>RIGHT)==FlipMask), "Illegal FlipMask (polarity) in GpioField");

   /**
    * Calculate Port bit-mask from field bit number
    *
    * @param bitNum  Bit number within field (left-right,0]
    *
    * @return Mask for given bit within underlying port hardware
    */
   static constexpr uint32_t mask(uint32_t bitNum) {
      return 1<<(bitNum+RIGHT);
   }

   /**
    *  Disable Pins
    *  This sets the pins to MUX(0) which is specified for minimum leakage in low-power modes.
    *
    *  @note The clock is left enabled as shared with other pins.
    *  @note Mux(0) is also the Analogue MUX setting
    */
   static void disablePins() {
      // Enable clock to port
      PcrBase::enablePortClock(Left);
      /*
       * Set all PCRs.
       */
      if constexpr (BITMASK & 0xFFFF) {
         Port::port->GPCLR = PORT_GPCLR_GPWE(BITMASK) | PORT_GPCLR_GPWD(PinMux_Disabled);
      }
      if constexpr (BITMASK & 0xFFFF0000) {
         Port::port->GPCLR = PORT_GPCHR_GPWE(BITMASK>>16) | PORT_GPCHR_GPWD(PinMux_Disabled);
      }
   }

   /**
    * Set field as digital I/O.
    * Pins are initially set as an input.
    * Use setIn(), setOut() and setDirection() to change pin directions.
    *
    * @note Resets the Pin Control Register values (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pcrValue PCR value to use in configuring pin (excluding MUX value)
    */
   static void setInOut(PcrValue pcrValue=defaultPcrValue) {
      // Enable clock to port
      PcrBase::enablePortClock(Left);

      // Default to input
      gpio->PDDR = gpio->PDDR & ~BITMASK;

      // Default to output inactive
      write(0);

      uint32_t pcr  = static_cast<uint32_t>(pcrValue);

#ifdef PORT_DFCR_CS_MASK
      if (pcr&PORT_PCR_DIGITALFILTER_MASK) {
         Port::port->DFER |= BITMASK;
      }
      else {
         Port::port->DFER &= ~BITMASK;
      }
      // Make sure MUX value is correct and clear PinFilter_Digital
      pcr = (pcr & ~(PORT_PCR_MUX_MASK|PORT_PCR_DIGITALFILTER_MASK)) | PinMux_Gpio;
#else
      // Make sure MUX value is correct
      pcr = (pcr & ~PORT_PCR_MUX_MASK) | PinMux_Gpio;
#endif
      /*
       * Set all PCRs.
       * Can't use GPCLR/GPCHR as doesn't affect IRQ function (PinAction)
       */
      for (unsigned bitNum=RIGHT; bitNum<=LEFT; bitNum++) {
         Port::port->PCR[bitNum] = pcr;
      }
   }
   /**
    * Set pin as digital I/O.
    * Pins are initially set as inputs.
    * Use setIn(), setOut() and setDirection() to change pin directions.
    * If open-drain then input function may meaningfully be used while set as output
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param pinPull          Pin pull device (up/down/none) on digital inputs
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinAction        DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter        Pin filtering on digital inputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    */
   static void setInOut(
         PinPull          pinPull,
         PinDriveStrength pinDriveStrength = PinDriveStrength_Low,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinAction        pinAction        = PinAction_None,
         PinFilter        pinFilter        = PinFilter_None,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast)  {
   
      setInOut(pinPull|pinDriveStrength|pinDriveMode|pinAction|pinFilter|pinSlewRate);
   }

   /**
    * Set all pins as digital outputs.
    *
    * @note Does not affect other pin settings
    */
   static void setOut() {
      gpio->PDDR = gpio->PDDR | BITMASK;
   }
   /**
    * Sets all pin as digital outputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut(), setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    * @note PCR value is taken from the value set in Configure.usbdmProject
    */
   static void setOutput() {
      setInOut(defaultPcrValue.pcrValue());
      gpio->PDDR = gpio->PDDR | BITMASK;
   }
   /**
    * Sets all pin as digital outputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut(), setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding mux fn)
    */
   static void setOutput(PcrValue pcrValue) {
      setInOut(pcrValue);
      gpio->PDDR = gpio->PDDR | BITMASK;
   }
   /**
    * @brief
    * Set all pins as digital outputs with initial inactive level
    * Configures <b>all</b> Pin Control Register (PCR) values

    * Unreferenced PCR fields are cleared.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut(), setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param pinDriveStrength Pin drive strength of digital outputs
    * @param pinDriveMode     Pin drive mode (push-pull/open-drain) of digital outputs
    * @param pinSlewRate      Pin slew rate of digital outputs
    */
   static void setOutput(
         PinDriveStrength pinDriveStrength,
         PinDriveMode     pinDriveMode     = PinDriveMode_PushPull,
         PinSlewRate      pinSlewRate      = PinSlewRate_Fast)  {
   
      setOutput(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /**
    * Set all pins as digital inputs.
    *
    * @note Does not affect other pin settings
    */
   static void setIn() {
      gpio->PDDR = gpio->PDDR & ~BITMASK;
   }
   /**
    * Set all pins as digital inputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut(), setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @note PCR value is taken from the value set in Configure.usbdmProject
    */
   static void setInput() {
      setInOut(defaultPcrValue.pcrValue());
   }
   /**
    * Set all pins as digital inputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut(), setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding mux and irq functions)
    */
   static void setInput(PcrValue pcrValue) {
      setInOut(pcrValue);
   }

   /**
    * Set all pins as digital inputs
    * Configures <b>all</b> Pin Control Register (PCR) values
    * Unreferenced fields are cleared.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    *
    * @param pinPull   Pin pull device (up/down/none) on digital inputs
    * @param pinAction DMA and/or interrupt actions to happen on pin change or level
    * @param pinFilter Pin filtering on digital inputs
    */
   static void setInput(
         PinPull   pinPull,
         PinAction pinAction = PinAction_None,
         PinFilter pinFilter = PinFilter_None)  {
   
      setInOut(pinPull|pinAction|pinFilter);
   }

   /**
    * Set individual pin directions
    *
    * @param[in] mask Mask for pin directions (1=>out, 0=>in)
    *
    * @note Does not affect other pin settings
    */
   static void setDirection(uint32_t mask) {
      gpio->PDDR = (gpio->PDDR&~BITMASK)|((mask<<RIGHT)&BITMASK);
   }
   /**
    * Set bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => set bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitSet(const uint32_t mask) {
      gpio->PSOR = (mask<<RIGHT)&BITMASK;
   }
   /**
    * Clear bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => clear bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitClear(const uint32_t mask) {
      gpio->PCOR = (mask<<RIGHT)&BITMASK;
   }
   /**
    * Toggle bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => toggle bit, 0 => unchanged)
    */
   static void bitToggle(const uint32_t mask) {
      gpio->PTOR = (mask<<RIGHT)&BITMASK;
   }
   /**
    * Read field as unmodified bit field
    *
    * @return value from field
    *
    * @note Polarity _is_ _not_ significant
    */
   static uint32_t bitRead() {
      return (gpio->PDIR & BITMASK)>>RIGHT;
   }
   /**
    * Read field
    *
    * @return value from field
    *
    * @note Polarity _is_ significant
    */
   static uint32_t read() {
      if constexpr (FLIP_MASK==0) {
         return (gpio->PDIR & BITMASK)>>RIGHT;
      }
      if constexpr (FLIP_MASK==0xFFFFFFFFUL) {
         return (~gpio->PDIR & BITMASK)>>RIGHT;
      }
      return ((gpio->PDIR^FLIP_MASK) & BITMASK)>>RIGHT;
   }
   /**
    * Read value being driven to field pins (if configured as output)
    *
    * @return value from field output
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   static uint32_t readState() {
      if constexpr (FLIP_MASK==0) {
         return (gpio->PDOR & BITMASK)>>RIGHT;
      }
      if constexpr (FLIP_MASK==0xFFFFFFFFUL) {
         return (~gpio->PDOR & BITMASK)>>RIGHT;
      }
      return ((gpio->PDOR^FLIP_MASK) & BITMASK)>>RIGHT;
   }
   /**
    * Write field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ significant
    */
   static void write(uint32_t value) {
      if constexpr (FLIP_MASK == 0xFFFFFFFFUL) {
         value = ~value;
      }
      else if constexpr (FLIP_MASK != 0) {
         value = value^(FLIP_MASK>>RIGHT);
      }
      {
         USBDM::CriticalSection cs;
         gpio->PDOR = ((gpio->PDOR) & ~BITMASK) | ((value<<RIGHT)&BITMASK);
      }
   }

   /**
    * Write bit field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitWrite(uint32_t value) {
      USBDM::CriticalSection cs;
      gpio->PDOR = ((gpio->PDOR) & ~BITMASK) | ((value<<RIGHT)&BITMASK);
   }

   /**
    * Set callback for Pin interrupts
    *
    * @param[in] callback The function to call on Pin interrupt. \n
    *                     nullptr to indicate none
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note There is a single callback function for all pins on the related port.
    *       It is necessary to identify the originating pin in the callback
    * @note This is a convenience function for Pcr::setPinCallback(callback)
    */
   static ErrorCode setPinCallback(PinCallbackFunction callback) {
      static_assert(Port::HANDLER_INSTALLED, "Gpio containing GpioField not configured for interrupts - Modify Configure.usbdm");
      return Port::setPinCallback(callback);
   }

   /**
    * @brief Convenience template for Gpios associated with a bit of this field. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate a 4-bit field in GPIO C
    * using Field = GpioCField<5, 2, ActiveHigh>;
    *
    * // Instantiate a GPIO within the field ( <=> GpioC<4, ActiveLow>)
    * using Bit = Field::Bit<2, ActiveLow>;
    *
    * @endcode
    *
    * @tparam bitNum        Bit number within the <em>field</em>
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<unsigned bitNum> class Bit :
   public Gpio_T<GPIO_DEFAULT_PCR, PinIndex(bitNum+RIGHT), (FLIP_MASK&(1UL<<bitNum))?ActiveLow:ActiveHigh> {
      static_assert(bitNum<=(LEFT-RIGHT), "Bit does not exist in field");
   public:
      // Allow access to owning field
      using Owner = GpioField_T;
   };
};

/**
 * Creates a GpioField from an Info class and bit numbers
 *
 * @tparam Info
 * @tparam left
 * @tparam right
 * @tparam polarity
 */
template<class Info, PinIndex left, PinIndex right, Polarity polarity>
class GpioFieldTable_T :
      public GpioField_T<Info::info[right].pcrValue, left, right, polarity> {

      static constexpr int bitNum = Info::info[right].pinIndex;

      // Tests are chained so only a single assertion can fail so as to reduce noise
      // Out of bounds value for field boundaries
      static constexpr bool Test1 = ((Info::numSignals)>=left) && (left>=right);
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || ((Info::info[left].pinIndex != PinIndex::UNMAPPED_PCR) && (Info::info[right].pinIndex != PinIndex::UNMAPPED_PCR));
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || ((Info::info[left].pinIndex >= 0) || (Info::info[right].pinIndex >= 0));

      static_assert(Test1, "Illegal field boundaries");
      static_assert(Test2, "GPIO bit in field is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "GPIO bit doesn't exist in this device/package - Check Configure.usbdm for available channels");
};

   /**
    * @brief Convenience template for GpioA. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 3 of GpioA
    * using GpioA3 = GpioA<3, ActiveHigh>;
    *
    * // Set as digital output
    * GpioA3::setOutput();
    *
    * // Set pin high
    * GpioA3::set();
    *
    * // Set pin low
    * GpioA3::clear();
    *
    * // Toggle pin
    * GpioA3::toggle();
    *
    * // Set pin to boolean value
    * GpioA3::write(true);
    *
    * // Set pin to boolean value
    * GpioA3::write(false);
    *
    * // Set as digital input
    * GpioA3::setInput();
    *
    * // Read pin as boolean value
    * bool x = GpioA3::read();
    * @endcode
    *
    * @tparam bitNum        Bit number in the port
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<int bitNum, Polarity polarity=ActiveHigh> class GpioA :
         public Gpio_T<GpioAInfo::info[bitNum].pcrValue, PcrBase::pinIndexOf(PinIndex::PTA0,bitNum), polarity> {};
   /**
    * Common features shared across all pins of PortA
    */
   typedef PcrBase_T<mapPinToPort(PinIndex::PTA0)> PortA;

   /**
    * @brief Convenience template for GpioA fields. See @ref GpioField_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 6 down to 3 of GpioA
    * using GpioA6_3 = GpioAField<6,3>;
    *
    * // Set as digital output
    * GpioA6_3::setOutput();
    *
    * // Write value to field
    * GpioA6_3::write(0x53);
    *
    * // Clear all of field
    * GpioA6_3::bitClear();
    *
    * // Clear lower two bits of field
    * GpioA6_3::bitClear(0x3);
    *
    * // Set lower two bits of field
    * GpioA6_3::bitSet(0x3);
    *
    * // Set as digital input
    * GpioA6_3::setInput();
    *
    * // Read pin as int value
    * int x = GpioA6_3::read();
    * @endcode
    *
    * @tparam left          Bit number of leftmost bit in port (inclusive)
    * @tparam right         Bit number of rightmost bit in port (inclusive)
    * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
    */
   template<int left, int right, uint32_t polarity=ActiveHigh>
   class GpioAField : public GpioField_T<GPIO_DEFAULT_PCR, PcrBase::pinIndexOf(PinIndex::PTA0,left), PcrBase::pinIndexOf(PinIndex::PTA0,right), Polarity(polarity)> {};

   /**
    * @brief Convenience template for GpioB. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 3 of GpioB
    * using GpioB3 = GpioB<3, ActiveHigh>;
    *
    * // Set as digital output
    * GpioB3::setOutput();
    *
    * // Set pin high
    * GpioB3::set();
    *
    * // Set pin low
    * GpioB3::clear();
    *
    * // Toggle pin
    * GpioB3::toggle();
    *
    * // Set pin to boolean value
    * GpioB3::write(true);
    *
    * // Set pin to boolean value
    * GpioB3::write(false);
    *
    * // Set as digital input
    * GpioB3::setInput();
    *
    * // Read pin as boolean value
    * bool x = GpioB3::read();
    * @endcode
    *
    * @tparam bitNum        Bit number in the port
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<int bitNum, Polarity polarity=ActiveHigh> class GpioB :
         public Gpio_T<GpioBInfo::info[bitNum].pcrValue, PcrBase::pinIndexOf(PinIndex::PTB0,bitNum), polarity> {};
   /**
    * Common features shared across all pins of PortB
    */
   typedef PcrBase_T<mapPinToPort(PinIndex::PTB0)> PortB;

   /**
    * @brief Convenience template for GpioB fields. See @ref GpioField_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 6 down to 3 of GpioB
    * using GpioB6_3 = GpioBField<6,3>;
    *
    * // Set as digital output
    * GpioB6_3::setOutput();
    *
    * // Write value to field
    * GpioB6_3::write(0x53);
    *
    * // Clear all of field
    * GpioB6_3::bitClear();
    *
    * // Clear lower two bits of field
    * GpioB6_3::bitClear(0x3);
    *
    * // Set lower two bits of field
    * GpioB6_3::bitSet(0x3);
    *
    * // Set as digital input
    * GpioB6_3::setInput();
    *
    * // Read pin as int value
    * int x = GpioB6_3::read();
    * @endcode
    *
    * @tparam left          Bit number of leftmost bit in port (inclusive)
    * @tparam right         Bit number of rightmost bit in port (inclusive)
    * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
    */
   template<int left, int right, uint32_t polarity=ActiveHigh>
   class GpioBField : public GpioField_T<GPIO_DEFAULT_PCR, PcrBase::pinIndexOf(PinIndex::PTB0,left), PcrBase::pinIndexOf(PinIndex::PTB0,right), Polarity(polarity)> {};

   /**
    * @brief Convenience template for GpioC. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 3 of GpioC
    * using GpioC3 = GpioC<3, ActiveHigh>;
    *
    * // Set as digital output
    * GpioC3::setOutput();
    *
    * // Set pin high
    * GpioC3::set();
    *
    * // Set pin low
    * GpioC3::clear();
    *
    * // Toggle pin
    * GpioC3::toggle();
    *
    * // Set pin to boolean value
    * GpioC3::write(true);
    *
    * // Set pin to boolean value
    * GpioC3::write(false);
    *
    * // Set as digital input
    * GpioC3::setInput();
    *
    * // Read pin as boolean value
    * bool x = GpioC3::read();
    * @endcode
    *
    * @tparam bitNum        Bit number in the port
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<int bitNum, Polarity polarity=ActiveHigh> class GpioC :
         public Gpio_T<GpioCInfo::info[bitNum].pcrValue, PcrBase::pinIndexOf(PinIndex::PTC0,bitNum), polarity> {};
   /**
    * Common features shared across all pins of PortC
    */
   typedef PcrBase_T<mapPinToPort(PinIndex::PTC0)> PortC;

   /**
    * @brief Convenience template for GpioC fields. See @ref GpioField_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 6 down to 3 of GpioC
    * using GpioC6_3 = GpioCField<6,3>;
    *
    * // Set as digital output
    * GpioC6_3::setOutput();
    *
    * // Write value to field
    * GpioC6_3::write(0x53);
    *
    * // Clear all of field
    * GpioC6_3::bitClear();
    *
    * // Clear lower two bits of field
    * GpioC6_3::bitClear(0x3);
    *
    * // Set lower two bits of field
    * GpioC6_3::bitSet(0x3);
    *
    * // Set as digital input
    * GpioC6_3::setInput();
    *
    * // Read pin as int value
    * int x = GpioC6_3::read();
    * @endcode
    *
    * @tparam left          Bit number of leftmost bit in port (inclusive)
    * @tparam right         Bit number of rightmost bit in port (inclusive)
    * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
    */
   template<int left, int right, uint32_t polarity=ActiveHigh>
   class GpioCField : public GpioField_T<GPIO_DEFAULT_PCR, PcrBase::pinIndexOf(PinIndex::PTC0,left), PcrBase::pinIndexOf(PinIndex::PTC0,right), Polarity(polarity)> {};

   /**
    * @brief Convenience template for GpioD. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 3 of GpioD
    * using GpioD3 = GpioD<3, ActiveHigh>;
    *
    * // Set as digital output
    * GpioD3::setOutput();
    *
    * // Set pin high
    * GpioD3::set();
    *
    * // Set pin low
    * GpioD3::clear();
    *
    * // Toggle pin
    * GpioD3::toggle();
    *
    * // Set pin to boolean value
    * GpioD3::write(true);
    *
    * // Set pin to boolean value
    * GpioD3::write(false);
    *
    * // Set as digital input
    * GpioD3::setInput();
    *
    * // Read pin as boolean value
    * bool x = GpioD3::read();
    * @endcode
    *
    * @tparam bitNum        Bit number in the port
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<int bitNum, Polarity polarity=ActiveHigh> class GpioD :
         public Gpio_T<GpioDInfo::info[bitNum].pcrValue, PcrBase::pinIndexOf(PinIndex::PTD0,bitNum), polarity> {};
   /**
    * Common features shared across all pins of PortD
    */
   typedef PcrBase_T<mapPinToPort(PinIndex::PTD0)> PortD;

   /**
    * @brief Convenience template for GpioD fields. See @ref GpioField_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 6 down to 3 of GpioD
    * using GpioD6_3 = GpioDField<6,3>;
    *
    * // Set as digital output
    * GpioD6_3::setOutput();
    *
    * // Write value to field
    * GpioD6_3::write(0x53);
    *
    * // Clear all of field
    * GpioD6_3::bitClear();
    *
    * // Clear lower two bits of field
    * GpioD6_3::bitClear(0x3);
    *
    * // Set lower two bits of field
    * GpioD6_3::bitSet(0x3);
    *
    * // Set as digital input
    * GpioD6_3::setInput();
    *
    * // Read pin as int value
    * int x = GpioD6_3::read();
    * @endcode
    *
    * @tparam left          Bit number of leftmost bit in port (inclusive)
    * @tparam right         Bit number of rightmost bit in port (inclusive)
    * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
    */
   template<int left, int right, uint32_t polarity=ActiveHigh>
   class GpioDField : public GpioField_T<GPIO_DEFAULT_PCR, PcrBase::pinIndexOf(PinIndex::PTD0,left), PcrBase::pinIndexOf(PinIndex::PTD0,right), Polarity(polarity)> {};

   /**
    * @brief Convenience template for GpioE. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 3 of GpioE
    * using GpioE3 = GpioE<3, ActiveHigh>;
    *
    * // Set as digital output
    * GpioE3::setOutput();
    *
    * // Set pin high
    * GpioE3::set();
    *
    * // Set pin low
    * GpioE3::clear();
    *
    * // Toggle pin
    * GpioE3::toggle();
    *
    * // Set pin to boolean value
    * GpioE3::write(true);
    *
    * // Set pin to boolean value
    * GpioE3::write(false);
    *
    * // Set as digital input
    * GpioE3::setInput();
    *
    * // Read pin as boolean value
    * bool x = GpioE3::read();
    * @endcode
    *
    * @tparam bitNum        Bit number in the port
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<int bitNum, Polarity polarity=ActiveHigh> class GpioE :
         public Gpio_T<GpioEInfo::info[bitNum].pcrValue, PcrBase::pinIndexOf(PinIndex::PTE0,bitNum), polarity> {};
   /**
    * Common features shared across all pins of PortE
    */
   typedef PcrBase_T<mapPinToPort(PinIndex::PTE0)> PortE;

   /**
    * @brief Convenience template for GpioE fields. See @ref GpioField_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate for bit 6 down to 3 of GpioE
    * using GpioE6_3 = GpioEField<6,3>;
    *
    * // Set as digital output
    * GpioE6_3::setOutput();
    *
    * // Write value to field
    * GpioE6_3::write(0x53);
    *
    * // Clear all of field
    * GpioE6_3::bitClear();
    *
    * // Clear lower two bits of field
    * GpioE6_3::bitClear(0x3);
    *
    * // Set lower two bits of field
    * GpioE6_3::bitSet(0x3);
    *
    * // Set as digital input
    * GpioE6_3::setInput();
    *
    * // Read pin as int value
    * int x = GpioE6_3::read();
    * @endcode
    *
    * @tparam left          Bit number of leftmost bit in port (inclusive)
    * @tparam right         Bit number of rightmost bit in port (inclusive)
    * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
    */
   template<int left, int right, uint32_t polarity=ActiveHigh>
   class GpioEField : public GpioField_T<GPIO_DEFAULT_PCR, PcrBase::pinIndexOf(PinIndex::PTE0,left), PcrBase::pinIndexOf(PinIndex::PTE0,right), Polarity(polarity)> {};


/**
 * End GPIO_Group
 * @}
 */

#pragma GCC pop_options

} // End namespace USBDM

#endif /* HEADER_GPIO_H */

